/**
 * @file
 * VuoCompiler implementation.
 *
 * @copyright Copyright © 2012–2017 Kosada Incorporated.
 * This code may be modified and distributed under the terms of the GNU Lesser General Public License (LGPL) version 2 or later.
 * For more information, see http://vuo.org/license.
 */

#include <fcntl.h>
#include <string.h>
#include <sstream>
#include <locale>
#include <CoreFoundation/CoreFoundation.h>
#include "VuoCompiler.hh"
#include "VuoCompilerBitcodeGenerator.hh"
#include "VuoCompilerBitcodeParser.hh"
#include "VuoCompilerCodeGenUtilities.hh"
#include "VuoCompilerComposition.hh"
#include "VuoCompilerException.hh"
#include "VuoCompilerGenericType.hh"
#include "VuoCompilerGraphvizParser.hh"
#include "VuoCompilerMakeListNodeClass.hh"
#include "VuoCompilerNode.hh"
#include "VuoCompilerNodeClass.hh"
#include "VuoCompilerPort.hh"
#include "VuoCompilerPortClass.hh"
#include "VuoCompilerPublishedInputNodeClass.hh"
#include "VuoCompilerPublishedOutputNodeClass.hh"
#include "VuoCompilerSpecializedNodeClass.hh"
#include "VuoCompilerTriggerDescription.hh"
#include "VuoGenericType.hh"
#include "VuoNode.hh"
#include "VuoNodeSet.hh"
#include "VuoPort.hh"
#include "VuoPublishedPort.hh"
#include "VuoRunner.hh"
#include "VuoStringUtilities.hh"

#ifdef PREMIUM_NODE_LOADER_ENABLED
#define VUO_PREMIUM_INITIALIZER
#include "VuoPremium.hh"
#endif

bool VuoCompiler::isLlvmInitialized = false;
dispatch_queue_t VuoCompiler::llvmQueue = dispatch_queue_create("org.vuo.compiler.llvm", NULL);
dispatch_queue_t VuoCompiler::environmentQueue = dispatch_queue_create("org.vuo.compiler.environment", NULL);
dispatch_queue_t VuoCompiler::cachedResourcesQueue = dispatch_queue_create("org.vuo.compiler.cache", NULL);
const int VuoCompiler::NUM_CACHES = 2;
bool VuoCompiler::hasTriedCachedResources[2] = { false, false };
string VuoCompiler::cachedResourceDylib[2];
set<string> VuoCompiler::cachedResources[2];
set<string> VuoCompiler::encounteredPremiumModules;
VuoCompiler::Environment * VuoCompiler::sharedEnvironment = NULL;
map<string, pair<string, VuoCompilerException> > VuoCompiler::errorsLoadingModules;
dispatch_queue_t VuoCompiler::errorsLoadingModulesQueue = dispatch_queue_create("org.vuo.compiler.errors", NULL);

/**
 * Needed so this type can be used in STL sets.
 */
bool operator<(const VuoCompiler::ModuleInfo &lhs, const VuoCompiler::ModuleInfo &rhs)
{
	return (lhs.searchPath != rhs.searchPath ?
								  lhs.searchPath < rhs.searchPath :
								  lhs.moduleKey < rhs.moduleKey);
}

/**
 * Creates an empty environment.
 */
VuoCompiler::Environment::Environment(bool isOwner)
{
	this->isOwner = isOwner;
}

/**
 * Destructor.
 */
VuoCompiler::Environment::~Environment(void)
{
	if (! isOwner)
		return;

	set<Module *> modulesToDelete;

	for (map<string, VuoCompilerNodeClass *>::iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoNodeClass *base = i->second->getBase();
		delete i->second;
		delete base;
	}
	for (map<string, VuoCompilerType *>::iterator i = types.begin(); i != types.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoType *base = i->second->getBase();
		delete i->second;
		delete base;
	}
	for (set<VuoCompilerGenericType *>::iterator i = genericTypes.begin(); i != genericTypes.end(); ++i)
	{
		VuoType *base = (*i)->getBase();
		delete *i;
		delete base;
	}
	for (map<string, VuoCompilerModule *>::iterator i = libraryModules.begin(); i != libraryModules.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoModule *base = i->second->getPseudoBase();
		delete i->second;
		delete base;
	}

	for (set<Module *>::iterator i = modulesToDelete.begin(); i != modulesToDelete.end(); ++i)
		deleteModule(*i);

	for (map<string, VuoNodeSet *>::iterator i = nodeSetForName.begin(); i != nodeSetForName.end(); ++i)
		delete i->second;

	for (map<string, map<string, VuoFileUtilities::File *> >::iterator i = moduleFilesAtSearchPath.begin(); i != moduleFilesAtSearchPath.end(); ++i)
		for (map<string, VuoFileUtilities::File *>::iterator j = i->second.begin(); j != i->second.end(); ++j)
			delete j->second;
}

/**
 * Returns the node classes loaded, plus specialized node classes generated by the compiler.
 */
map<string, VuoCompilerNodeClass *> VuoCompiler::Environment::getNodeClasses(void)
{
	__block map<string, VuoCompilerNodeClass *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = nodeClasses;
				  });
	return ret;
}

/**
 * Returns the node class with the given @a moduleKey, or null if no node class by that name has been loaded.
 */
VuoCompilerNodeClass * VuoCompiler::Environment::getNodeClass(const string &moduleKey)
{
	__block VuoCompilerNodeClass *nodeClass = NULL;
	dispatch_sync(environmentQueue, ^{
					  map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(moduleKey);
					  if (nodeClassIter != nodeClasses.end())
						  nodeClass = nodeClassIter->second;
				  });
	return nodeClass;
}

/**
 * Returns the types loaded.
 */
map<string, VuoCompilerType *> VuoCompiler::Environment::getTypes(void)
{
	__block map<string, VuoCompilerType *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = types;
				  });
	return ret;
}

/**
 * Returns the type with the given @a moduleKey, or null if no type by that name has been loaded.
 */
VuoCompilerType * VuoCompiler::Environment::getType(const string &moduleKey)
{
	__block VuoCompilerType *type = NULL;
	dispatch_sync(environmentQueue, ^{
					  map<string, VuoCompilerType *>::iterator typeIter = types.find(moduleKey);
					  if (typeIter != types.end())
						  type = typeIter->second;
				  });
	return type;
}

/**
 * Returns the node sets loaded.
 */
map<string, VuoNodeSet *> VuoCompiler::Environment::getNodeSets(void)
{
	__block map<string, VuoNodeSet *> ret;
	dispatch_sync(environmentQueue, ^{
		ret = nodeSetForName;
	});
	return ret;
}

/**
 * Returns the library modules loaded.
 */
map<string, VuoCompilerModule *> VuoCompiler::Environment::getLibraryModules(void)
{
	__block map<string, VuoCompilerModule *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = libraryModules;
				  });
	return ret;
}

/**
 * Returns the library modules with the given @a moduleKey, or null if no library module by that name has been loaded.
 */
VuoCompilerModule * VuoCompiler::Environment::getLibraryModule(const string &moduleKey)
{
	__block VuoCompilerModule *libraryModule = NULL;
	dispatch_sync(environmentQueue, ^{
					  map<string, VuoCompilerModule *>::iterator libraryModuleIter = libraryModules.find(moduleKey);
					  if (libraryModuleIter != libraryModules.end())
						  libraryModule = libraryModuleIter->second;
				  });
	return libraryModule;
}

/**
 * Returns the VuoCompilerNodeClass, VuoCompilerType, or VuoCompilerModule with the given name,
 * or null if no such module has been loaded.
 */
VuoCompilerModule * VuoCompiler::Environment::findModule(const string &moduleKey)
{
	__block VuoCompilerModule *module;
	dispatch_sync(environmentQueue, ^{
					  module = findModuleThreadUnsafe(moduleKey);
				  });
	return module;
}

/**
 * Returns the VuoCompilerNodeClass, VuoCompilerType, or VuoCompilerModule with the given name,
 * or null if no such module has been loaded.
 *
 * @threadQueue{environmentQueue}
 */
VuoCompilerModule * VuoCompiler::Environment::findModuleThreadUnsafe(const string &moduleKey)
{
	map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(moduleKey);
	if (nodeClassIter != nodeClasses.end())
		return nodeClassIter->second;

	map<string, VuoCompilerType *>::iterator typeIter = types.find(moduleKey);
	if (typeIter != types.end())
		return typeIter->second;

	map<string, VuoCompilerModule *>::iterator libraryIter = libraryModules.find(moduleKey);
	if (libraryIter != libraryModules.end())
		return libraryIter->second;

	return NULL;
}

/**
 * Returns the node set with the given name, or null if no such node set been loaded.
 */
VuoNodeSet * VuoCompiler::Environment::findNodeSet(const string &name)
{
	__block VuoNodeSet *nodeSet = NULL;

	dispatch_sync(environmentQueue, ^{
					  map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(name);
					  if (nodeSetIter != nodeSetForName.end())
					  {
						  nodeSet = nodeSetIter->second;
					  }
				  });

	return nodeSet;
}

/**
 * Adds a search path for node classes, types, and library modules.
 */
void VuoCompiler::Environment::addModuleSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  moduleSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for node classes, types, and library modules.
 */
vector<string> VuoCompiler::Environment::getModuleSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = moduleSearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for header/include files.
 */
void VuoCompiler::Environment::addHeaderSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  headerSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for header/include files.
 */
vector<string> VuoCompiler::Environment::getHeaderSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = headerSearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for libraries (other than Vuo library modules).
 */
void VuoCompiler::Environment::addLibrarySearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  librarySearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for libraries (other than Vuo library modules).
 */
vector<string> VuoCompiler::Environment::getLibrarySearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = librarySearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for frameworks.
 */
void VuoCompiler::Environment::addFrameworkSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  frameworkSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for frameworks.
 */
vector<string> VuoCompiler::Environment::getFrameworkSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = frameworkSearchPaths;
				  });
	return ret;
}

/**
 * Loads each module in @a modulesToLoadArg into the environment specified by its ModuleInfo,
 * if it has not already been loaded.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::loadModulesIntoCombinedEnvironment(Environment *myEnvironment, Environment *sharedEnvironment,
																  list<ModuleInfo> modulesToLoadArg)
{
	__block list<ModuleInfo> modulesToLoad = modulesToLoadArg;

	dispatch_sync(environmentQueue, ^{
					  bool wereModulesLoaded = false;

					  while (! modulesToLoad.empty())
					  {
						  ModuleInfo moduleInfo = modulesToLoad.front();
						  modulesToLoad.pop_front();

						  // Skip the module if it's already been loaded.
						  if (myEnvironment->findModuleThreadUnsafe(moduleInfo.moduleKey) ||
								  sharedEnvironment->findModuleThreadUnsafe(moduleInfo.moduleKey) ||
								  encounteredPremiumModules.find(moduleInfo.moduleKey) != encounteredPremiumModules.end())
							  continue;

						  vector<string> parts = VuoStringUtilities::split(moduleInfo.moduleKey, '.');
						  if (VuoCompilerMakeListNodeClass::isMakeListNodeClassName(moduleInfo.moduleKey))
						  {
							  // For a `Make List` node class, also need to load the item and list types.
							  string itemType = parts.back();
							  set<string> typeNames;
							  typeNames.insert(itemType);
							  typeNames.insert(VuoType::listTypeNamePrefix + itemType);
							  set<ModuleInfo> typeModuleInfos = sharedEnvironment->listModulesThreadUnsafe(typeNames);
							  modulesToLoad.insert(modulesToLoad.end(), typeModuleInfos.begin(), typeModuleInfos.end());
						  }
						  else
						  {
							  for (int j = parts.size() - 1; j >= 1; --j)
							  {
								  vector<string> firstParts(parts.begin(), parts.begin() + j);
								  string genericNodeClass = VuoStringUtilities::join(firstParts, '.');

								  set<string> genericNodeClassSet;
								  genericNodeClassSet.insert(genericNodeClass);
								  set<ModuleInfo> genericNodeClassModuleInfos = sharedEnvironment->listModulesThreadUnsafe(genericNodeClassSet);

								  if (! genericNodeClassModuleInfos.empty())
								  {
									  // For a generic node class, also need to load the types to which it's specialized.
									  set<string> lastParts(parts.begin() + j, parts.end());
									  set<ModuleInfo> typeModuleInfos = sharedEnvironment->listModulesThreadUnsafe(lastParts);
									  modulesToLoad.insert(modulesToLoad.end(), typeModuleInfos.begin(), typeModuleInfos.end());
								  }
							  }
						  }

						  // Actually load the module.
						  VuoCompilerModule *module = moduleInfo.environment->loadModule(moduleInfo);

						  if (module)
						  {
							  wereModulesLoaded = true;

							  set<string> dependencies = module->getDependencies();
							  set<ModuleInfo> moduleInfos = Environment::listModulesInEnvironmentsThreadUnsafe(myEnvironment, sharedEnvironment, dependencies);
							  modulesToLoad.insert(modulesToLoad.end(), moduleInfos.begin(), moduleInfos.end());
						  }
					  }

					  if (wereModulesLoaded)
					  {
						  sharedEnvironment->reifyPortTypes(NULL);
						  myEnvironment->reifyPortTypes(sharedEnvironment);
						  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
					  }
				  });
}

/**
 * Adds a node class to use when linking a composition.
 *
 * Typically, node classes are loaded from file with addModuleSearchPath().
 * This function is useful if adding a node class that is generated at compile time.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::addNodeClassToCombinedEnvironment(VuoCompilerNodeClass *nodeClass,
																 Environment *myEnvironment, Environment *sharedEnvironment)
{
	dispatch_sync(environmentQueue, ^{
					  dispatch_sync(llvmQueue, ^{
						  setTargetForModule(nodeClass->getModule());
					  });

					  string moduleKey = nodeClass->getBase()->getModuleKey();
					  myEnvironment->nodeClasses[moduleKey] = nodeClass;

					  myEnvironment->reifyPortTypes(sharedEnvironment);
					  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
				  });
}

/**
 * Removes a node class from the list of node classes known to the compiler/linker, and destroys the node class.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::removeNodeClassFromCombinedEnvironment(string nodeClassName,
																	  Environment *myEnvironment, Environment *sharedEnvironment)
{
	dispatch_sync(environmentQueue, ^{
					  VuoCompilerNodeClass *nodeClass = NULL;

					  map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = myEnvironment->nodeClasses.find(nodeClassName);
					  if (nodeClassIter != myEnvironment->nodeClasses.end())
					  {
						  nodeClass = nodeClassIter->second;
						  myEnvironment->nodeClasses.erase(nodeClassIter);
					  }
					  else
					  {
						  nodeClassIter = sharedEnvironment->nodeClasses.find(nodeClassName);
						  if (nodeClassIter != sharedEnvironment->nodeClasses.end())
						  {
							  nodeClass = nodeClassIter->second;
							  sharedEnvironment->nodeClasses.erase(nodeClassIter);
						  }
					  }

					  if (nodeClass)
					  {
						  Module *module = nodeClass->getModule();
						  VuoNodeClass *base = nodeClass->getBase();
						  delete nodeClass;
						  delete base;
						  deleteModule(module);

						  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
					  }
				  });
}

/**
 * Returns a list of all node classes, types, and library modules in the folder at @a path,
 *
 * The top level of the folder is searched for .vuonode, .vuonode+, .bc, and .bc+ files.
 * A .vuonode file may be either a module or an archive containing modules.
 * In the latter case, the .vuonode archive's top level is searched.
 *
 * The returned VuoFileUtilities::File objects are owned by the VuoCompiler instances, and
 * should not be freed by the caller.
 *
 * @threadQueue{environmentQueue}
 */
map<string, VuoFileUtilities::File *> VuoCompiler::Environment::listModulesAtSearchPath(const string &path)
{
	map<string, map<string, VuoFileUtilities::File *> >::iterator moduleFilesIter = moduleFilesAtSearchPath.find(path);
	if (moduleFilesIter != moduleFilesAtSearchPath.end())
		return moduleFilesIter->second;

	set<string> moduleExtensions;
	moduleExtensions.insert("vuonode");
	moduleExtensions.insert("vuonode+");
	moduleExtensions.insert("bc");
	moduleExtensions.insert("bc+");
	set<string> archiveExtensions;
	archiveExtensions.insert("vuonode");
	set<VuoFileUtilities::File *> moduleFiles = VuoFileUtilities::findFilesInDirectory(path, moduleExtensions, archiveExtensions);

	map<string, VuoFileUtilities::File *> fileForModuleKey;
	for (set<VuoFileUtilities::File *>::iterator i = moduleFiles.begin(); i != moduleFiles.end(); ++i)
	{
		VuoFileUtilities::File *moduleFile = *i;

		string dir, moduleKey, ext;
		VuoFileUtilities::splitPath(moduleFile->getRelativePath(), dir, moduleKey, ext);

		fileForModuleKey[moduleKey] = moduleFile;
	}

	moduleFilesAtSearchPath[path] = fileForModuleKey;

	if (path == getCachedModulesPath())
		removeCachedModulesForDeletedSubcompositions();

	return fileForModuleKey;
}

/**
 * Returns a list of all compositions in the folder at @a path,
 *
 * The top level of the folder is searched for .vuo files.
 *
 * The returned VuoFileUtilities::File objects are owned by the VuoCompiler instances, and
 * should not be freed by the caller.
 *
 * @threadQueue{environmentQueue}
 */
map<string, VuoFileUtilities::File *> VuoCompiler::Environment::listCompositionsAtSearchPath(const string &path)
{
	map<string, map<string, VuoFileUtilities::File *> >::iterator compositionFilesIter = compositionFilesAtSearchPath.find(path);
	if (compositionFilesIter != compositionFilesAtSearchPath.end())
		return compositionFilesIter->second;

	set<string> compositionExtensions;
	compositionExtensions.insert("vuo");
	set<VuoFileUtilities::File *> compositionFiles = VuoFileUtilities::findFilesInDirectory(path, compositionExtensions, set<string>());

	map<string, VuoFileUtilities::File *> fileForModuleKey;
	for (set<VuoFileUtilities::File *>::iterator i = compositionFiles.begin(); i != compositionFiles.end(); ++i)
	{
		VuoFileUtilities::File *compositionFile = *i;

		string dir, moduleKey, ext;
		VuoFileUtilities::splitPath(compositionFile->getRelativePath(), dir, moduleKey, ext);

		fileForModuleKey[moduleKey] = compositionFile;
	}

	compositionFilesAtSearchPath[path] = fileForModuleKey;

	return fileForModuleKey;
}

/**
 * Helper function for listModulesThreadUnsafe().
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listFiles(const set<string> &moduleKeys,
																 map<string, VuoFileUtilities::File *> (VuoCompiler::Environment::*listFiles)(const string &))
{
	set<ModuleInfo> moduleInfos;

	for (vector<string>::iterator i = moduleSearchPaths.begin(); i != moduleSearchPaths.end(); ++i)
	{
		map<string, VuoFileUtilities::File *> fileForModuleKey = (this->*listFiles)(*i);

		for (set<string>::const_iterator j = moduleKeys.begin(); j != moduleKeys.end(); ++j)
		{
			map<string, VuoFileUtilities::File *>::iterator iter = fileForModuleKey.find(*j);
			if (iter != fileForModuleKey.end())
			{
				ModuleInfo moduleInfo = { this, *i, iter->second, iter->first };
				moduleInfos.insert(moduleInfo);
			}
		}
	}

	return moduleInfos;
}

/**
 * Helper function for listAllModulesThreadUnsafe() and listAllSubcompositions().
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listAllFiles(map<string, VuoFileUtilities::File *> (VuoCompiler::Environment::*listFiles)(const string &))
{
	set<ModuleInfo> moduleInfos;

	for (vector<string>::iterator i = moduleSearchPaths.begin(); i != moduleSearchPaths.end(); ++i)
	{
		map<string, VuoFileUtilities::File *> fileForModuleKey = (this->*listFiles)(*i);

		for ( map<string, VuoFileUtilities::File *>::iterator j = fileForModuleKey.begin(); j != fileForModuleKey.end(); ++j)
		{
			ModuleInfo moduleInfo = { this, *i, j->second, j->first };
			moduleInfos.insert(moduleInfo);
		}
	}

	return moduleInfos;

}

/**
 * Returns info for each of the modules specified by @a moduleKeys that is found in one of the @ref moduleSearchPaths.
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listModules(const set<string> &moduleKeys)
{
	__block set<ModuleInfo> moduleInfos;
	dispatch_sync(environmentQueue, ^{
					  moduleInfos = listModulesThreadUnsafe(moduleKeys);
				  });
	return moduleInfos;
}

/**
 * Returns info for each of the modules specified by @a moduleKeys that is found in one of the @ref moduleSearchPaths.
 *
 * @threadQueue{environmentQueue}
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listModulesThreadUnsafe(const set<string> &moduleKeys)
{
	return listFiles(moduleKeys, &VuoCompiler::Environment::listModulesAtSearchPath);
}

/**
 * Returns info for all of the modules found in the @ref moduleSearchPaths.
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listAllModules(void)
{
	__block set<ModuleInfo> moduleInfos;
	dispatch_sync(environmentQueue, ^{
					  moduleInfos = listAllModulesThreadUnsafe();
				  });
	return moduleInfos;
}

/**
 * Returns info for all of the modules found in the @ref moduleSearchPaths.
 *
 * @threadQueue{environmentQueue}
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listAllModulesThreadUnsafe(void)
{
	return listAllFiles(&VuoCompiler::Environment::listModulesAtSearchPath);
}

/**
 * Returns info for each of the compositions specified by @a nodeClassNames that is found in one of the @ref moduleSearchPaths.
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listSubcompositions(const set<string> &nodeClassNames)
{
	return listFiles(nodeClassNames, &VuoCompiler::Environment::listCompositionsAtSearchPath);
}

/**
 * Returns info for all of the compositions found in the @ref moduleSearchPaths.
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listAllSubcompositions(void)
{
	__block set<ModuleInfo> moduleInfos;
	dispatch_sync(environmentQueue, ^{
					  moduleInfos = listAllFiles(&VuoCompiler::Environment::listCompositionsAtSearchPath);
				  });
	return moduleInfos;
}

/**
 * Returns info for each of the modules specified by @a moduleKeys that is found in the @ref moduleSearchPaths
 * of @a myEnvironment or @a sharedEnvironment.
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listModulesInEnvironments(Environment *myEnvironment, Environment *sharedEnvironment,
																				  const set<string> &moduleKeys)
{
	__block set<ModuleInfo> moduleInfos;
	dispatch_sync(environmentQueue, ^{
					  moduleInfos = listModulesInEnvironmentsThreadUnsafe(myEnvironment, sharedEnvironment, moduleKeys);
				  });
	return moduleInfos;
}

/**
 * Returns info for each of the modules specified by @a moduleKeys that is found in the @ref moduleSearchPaths
 * of @a myEnvironment or @a sharedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listModulesInEnvironmentsThreadUnsafe(Environment *myEnvironment, Environment *sharedEnvironment,
																							  const set<string> &moduleKeys)
{
	set<ModuleInfo> moduleInfos;
	set<ModuleInfo> moduleInfosInMyEnvironment = myEnvironment->listModulesThreadUnsafe(moduleKeys);
	set<ModuleInfo> moduleInfosInSharedEnvironment = sharedEnvironment->listModulesThreadUnsafe(moduleKeys);
	moduleInfos.insert(moduleInfosInMyEnvironment.begin(), moduleInfosInMyEnvironment.end());
	moduleInfos.insert(moduleInfosInSharedEnvironment.begin(), moduleInfosInSharedEnvironment.end());
	return moduleInfos;
}

/**
 * Returns info for all of the modules found in the @ref moduleSearchPaths of @a myEnvironment or @a sharedEnvironment.
 */
set<VuoCompiler::ModuleInfo> VuoCompiler::Environment::listAllModulesInEnvironments(Environment *myEnvironment, Environment *sharedEnvironment)
{
	__block set<ModuleInfo> moduleInfos;
	dispatch_sync(environmentQueue, ^{
					  set<ModuleInfo> moduleInfosInMyEnvironment = myEnvironment->listAllModulesThreadUnsafe();
					  set<ModuleInfo> moduleInfosInSharedEnvironment = sharedEnvironment->listAllModulesThreadUnsafe();
					  moduleInfos.insert(moduleInfosInMyEnvironment.begin(), moduleInfosInMyEnvironment.end());
					  moduleInfos.insert(moduleInfosInSharedEnvironment.begin(), moduleInfosInSharedEnvironment.end());
				  });
	return moduleInfos;
}

/**
 * Loads a node class, type, or library module from a file, and adds it to the environment.
 *
 * Assumes that the module is not already present in the environment.
 *
 * @threadQueue{environmentQueue}
 */
VuoCompilerModule * VuoCompiler::Environment::loadModule(const ModuleInfo &moduleInfo)
{
	// Skip certain LLVM modules that definitely aren't Vuo modules to avoid adding struct types defined in them to the LLVM
	// context, resulting in mismatched struct types in code generation (e.g. %struct.NodeContext and %struct.NodeContext.1).
	if (VuoStringUtilities::beginsWith(moduleInfo.moduleKey, "libVuo"))
		return NULL;

	size_t inputDataBytes;
	char *rawInputData;
	try
	{
		rawInputData = moduleInfo.file->getContentsAsRawData(inputDataBytes);
	}
	catch (const exception &e)
	{
		VUserLog("Warning: Couldn't load module '%s'. Its file may have been deleted. (%s)", moduleInfo.moduleKey.c_str(), e.what());
		return NULL;
	}
	char *processedInputData = NULL;

	bool moduleParseError = false;
	bool premiumModule = false;

	string dir, file, ext;
	VuoFileUtilities::splitPath(moduleInfo.file->getRelativePath(), dir, file, ext);

	if ((ext == "vuonode+") || (ext == "bc+"))
	{
		encounteredPremiumModules.insert(moduleInfo.moduleKey);

#ifdef PREMIUM_NODE_LOADER_ENABLED
		if (inputDataBytes <= INT_MAX)
			processedInputData = VuoPremium::getPremiumDataContent(rawInputData,
																   static_cast<int>(inputDataBytes),
																   moduleInfo.moduleKey.c_str());
#endif

		if (!processedInputData)
		{
			moduleParseError = true;
			//VUserLog("Error: Couldn't extract premium content from file '%s'.", moduleFile->getRelativePath().c_str());
		}

		free(rawInputData);
		premiumModule = true;
	}
	else
		processedInputData = rawInputData;

	Module *module = NULL;
	if (!moduleParseError)
	{
		string moduleReadError;
		module = readModuleFromBitcodeData(processedInputData, inputDataBytes, moduleReadError);
		free(processedInputData);

		if (!module)
		{
			moduleParseError = true;
			VUserLog("Error: Couldn't parse module '%s': %s.", moduleInfo.file->getRelativePath().c_str(), moduleReadError.c_str());
		}
	}

	if (!moduleParseError)
	{
		string modulePath;
		if (! moduleInfo.file->isInArchive())
			modulePath = moduleInfo.searchPath + "/" + moduleInfo.file->getRelativePath();

		__block VuoCompilerModule *compilerModule;
		dispatch_sync(llvmQueue, ^{
						  compilerModule = VuoCompilerModule::newModule(moduleInfo.moduleKey, module, modulePath);
					  });

		if (compilerModule)
		{
			if (dynamic_cast<VuoCompilerNodeClass *>(compilerModule))
				nodeClasses[moduleInfo.moduleKey] = static_cast<VuoCompilerNodeClass *>(compilerModule);
			else if (dynamic_cast<VuoCompilerType *>(compilerModule))
				types[moduleInfo.moduleKey] = static_cast<VuoCompilerType *>(compilerModule);
			else
				libraryModules[moduleInfo.moduleKey] = compilerModule;

			VuoNodeSet *nodeSet = VuoNodeSet::createNodeSetForModule(moduleInfo.file);
			if (nodeSet)
			{
				map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(nodeSet->getName());
				if (nodeSetIter == nodeSetForName.end())
				{
					nodeSetForName[nodeSet->getName()] = nodeSet;
				}
				else
				{
					delete nodeSet;
					nodeSet = nodeSetIter->second;
				}
				compilerModule->getPseudoBase()->setNodeSet(nodeSet);
			}

			compilerModule->setPremium(premiumModule);

			vector<string> builtInModuleSearchPaths = getBuiltInModuleSearchPaths();
			bool isBuiltIn = (find(builtInModuleSearchPaths.begin(), builtInModuleSearchPaths.end(), moduleInfo.searchPath) != builtInModuleSearchPaths.end());
			compilerModule->setBuiltIn(isBuiltIn);

			return compilerModule;
		}
		else
		{
			deleteModule(module);
		}
	}

	return NULL;
}

/**
 * Updates the data-and-event ports of each known node class to match them up with known types.
 * This method needs to be called between when the last node class or type is loaded and
 * when a composition is compiled. It can be called multiple times.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::reifyPortTypes(Environment *outerEnvironment)
{
	map<string, VuoCompilerNodeClass *> searchNodeClasses;
	map<string, VuoCompilerType *> searchTypes;

	if (outerEnvironment)
		searchNodeClasses.insert(outerEnvironment->nodeClasses.begin(), outerEnvironment->nodeClasses.end());
	searchNodeClasses.insert(nodeClasses.begin(), nodeClasses.end());

	if (outerEnvironment)
		searchTypes.insert(outerEnvironment->types.begin(), outerEnvironment->types.end());
	searchTypes.insert(types.begin(), types.end());

	for (map<string, VuoCompilerNodeClass *>::iterator i = searchNodeClasses.begin(); i != searchNodeClasses.end(); ++i)
	{
		VuoNodeClass *nodeClass = i->second->getBase();

		vector<VuoPortClass *> inputPortClasses = nodeClass->getInputPortClasses();
		vector<VuoPortClass *> outputPortClasses = nodeClass->getOutputPortClasses();
		vector<VuoPortClass *> portClasses;
		portClasses.insert(portClasses.end(), inputPortClasses.begin(), inputPortClasses.end());
		portClasses.insert(portClasses.end(), outputPortClasses.begin(), outputPortClasses.end());

		for (vector<VuoPortClass *>::iterator j = portClasses.begin(); j != portClasses.end(); ++j)
		{
			VuoCompilerPortClass *portClass = static_cast<VuoCompilerPortClass *>((*j)->getCompiler());
			VuoType *baseType = portClass->getDataVuoType();

			if (baseType && ! baseType->hasCompiler())
			{
				string typeName = baseType->getModuleKey();
				VuoCompilerType *reifiedType = NULL;

				VuoGenericType *genericType = dynamic_cast<VuoGenericType *>(baseType);
				if (genericType)
				{
					reifiedType = VuoCompilerGenericType::newGenericType(genericType, searchTypes);
					if (reifiedType)
						genericTypes.insert( static_cast<VuoCompilerGenericType *>(reifiedType) );
				}
				else
				{
					map<string, VuoCompilerType *>::iterator reifiedTypeIter = searchTypes.find(typeName);
					if (reifiedTypeIter != searchTypes.end())
					{
						delete baseType;
						reifiedType = reifiedTypeIter->second;
					}
				}

				if (reifiedType)
					portClass->setDataVuoType(reifiedType->getBase());
			}
		}

		vector<VuoCompilerTriggerDescription *> triggers = nodeClass->getCompiler()->getTriggerDescriptions();
		for (vector<VuoCompilerTriggerDescription *>::iterator j = triggers.begin(); j != triggers.end(); ++j)
		{
			VuoCompilerTriggerDescription *trigger = *j;
			VuoType *baseType = trigger->getDataType();

			if (baseType && ! baseType->hasCompiler())
			{
				string typeName = baseType->getModuleKey();
				map<string, VuoCompilerType *>::iterator reifiedTypeIter = searchTypes.find(typeName);
				if (reifiedTypeIter != searchTypes.end())
				{
					delete baseType;
					VuoCompilerType *reifiedType = reifiedTypeIter->second;
					trigger->setDataType(reifiedType->getBase());
				}
			}
		}
	}
}

/**
 * Updates this environment to consist of @a myEnvironment layered on top of @a sharedEnvironment.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::updateCombinedEnvironment(Environment *myEnvironment, Environment *sharedEnvironment)
{
	nodeClasses.clear();
	types.clear();
	genericTypes.clear();
	nodeSetForName.clear();
	libraryModules.clear();
	moduleFilesAtSearchPath.clear();
	compositionFilesAtSearchPath.clear();
	moduleSearchPaths.clear();
	headerSearchPaths.clear();
	librarySearchPaths.clear();
	frameworkSearchPaths.clear();

	Environment *envs[2] = { sharedEnvironment, myEnvironment };
	for (int i = 0; i < 2; ++i)
	{
		nodeClasses.insert(envs[i]->nodeClasses.begin(), envs[i]->nodeClasses.end());
		types.insert(envs[i]->types.begin(), envs[i]->types.end());
		genericTypes.insert(envs[i]->genericTypes.begin(), envs[i]->genericTypes.end());
		nodeSetForName.insert(envs[i]->nodeSetForName.begin(), envs[i]->nodeSetForName.end());
		libraryModules.insert(envs[i]->libraryModules.begin(), envs[i]->libraryModules.end());
		moduleFilesAtSearchPath.insert(envs[i]->moduleFilesAtSearchPath.begin(), envs[i]->moduleFilesAtSearchPath.end());
		compositionFilesAtSearchPath.insert(envs[i]->compositionFilesAtSearchPath.begin(), envs[i]->compositionFilesAtSearchPath.end());
		moduleSearchPaths.insert(moduleSearchPaths.end(), envs[i]->moduleSearchPaths.begin(), envs[i]->moduleSearchPaths.end());
		headerSearchPaths.insert(headerSearchPaths.end(), envs[i]->headerSearchPaths.begin(), envs[i]->headerSearchPaths.end());
		librarySearchPaths.insert(librarySearchPaths.end(), envs[i]->librarySearchPaths.begin(), envs[i]->librarySearchPaths.end());
		frameworkSearchPaths.insert(frameworkSearchPaths.end(), envs[i]->frameworkSearchPaths.begin(), envs[i]->frameworkSearchPaths.end());
	}
}

/**
 * Returns the search paths for built-in node classes, types, and library modules.
 */
vector<string> VuoCompiler::Environment::getBuiltInModuleSearchPaths(void)
{
	vector<string> builtInModuleSearchPaths;

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInModuleSearchPaths.push_back(vuoFrameworkPath + "/Modules");
	}
	else
	{
		builtInModuleSearchPaths.push_back(VUO_ROOT "/library");
		builtInModuleSearchPaths.push_back(VUO_ROOT "/node");
		builtInModuleSearchPaths.push_back(VUO_ROOT "/type");
		builtInModuleSearchPaths.push_back(VUO_ROOT "/type/list");
	}

	return builtInModuleSearchPaths;
}

/**
 * Returns the search paths for built-in libraries (other than library modules).
 */
vector<string> VuoCompiler::Environment::getBuiltInLibrarySearchPaths(void)
{
	vector<string> builtInLibrarySearchPaths;

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInLibrarySearchPaths.push_back(vuoFrameworkPath + "/Modules");
	}
	else
	{
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/library");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/node");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/type");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/type/list");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/runtime");

		builtInLibrarySearchPaths.push_back(JSONC_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(ZMQ_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LEAP_ROOT);
		builtInLibrarySearchPaths.push_back(MUPARSER_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(FREEIMAGE_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(CURL_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(RTMIDI_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(RTAUDIO_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(GAMMA_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(ASSIMP_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(FFMPEG_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBUSB_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBFREENECT_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(OSCPACK_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(ZXING_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBXML2_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBCSV_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(GETTEXT_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(GLIB_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(LIBLQR_ROOT "/lib");
		builtInLibrarySearchPaths.push_back(VUO_ROOT "/runtime");
	}

	return builtInLibrarySearchPaths;
}

/**
 * Adds the search paths needed by all compositions to this environment.
 *
 * This function should be called on VuoCompiler::sharedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::addSearchPathsToSharedEnvironment(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		frameworkSearchPaths.push_back(vuoFrameworkPath + "/Modules/");
		frameworkSearchPaths.push_back(vuoFrameworkPath + "/Frameworks/");

		headerSearchPaths.push_back(vuoFrameworkPath + "/Headers/");
		headerSearchPaths.push_back(vuoFrameworkPath + "/Headers/macos");  // system headers installed by Xcode Command Line Tools
	}
	else
	{
		headerSearchPaths.push_back(VUO_ROOT "/library");
		headerSearchPaths.push_back(VUO_ROOT "/node");
		headerSearchPaths.push_back(VUO_ROOT "/type");
		headerSearchPaths.push_back(VUO_ROOT "/type/list");
		headerSearchPaths.push_back(VUO_ROOT "/runtime");
		headerSearchPaths.push_back(JSONC_ROOT "/include");

		frameworkSearchPaths.push_back(SYPHON_ROOT);
	}

	vector<string> builtInModuleSearchPaths = getBuiltInModuleSearchPaths();
	moduleSearchPaths.insert(moduleSearchPaths.end(), builtInModuleSearchPaths.begin(), builtInModuleSearchPaths.end());
	vector<string> builtInLibrarySearchPaths = getBuiltInLibrarySearchPaths();
	librarySearchPaths.insert(librarySearchPaths.end(), builtInLibrarySearchPaths.begin(), builtInLibrarySearchPaths.end());

	// Allow system administrator to override Vuo.framework modules
	moduleSearchPaths.push_back(VuoFileUtilities::getSystemModulesPath());
	librarySearchPaths.push_back(VuoFileUtilities::getSystemModulesPath());

	// Allow user to override Vuo.framework and system-wide modules
	moduleSearchPaths.push_back(VuoFileUtilities::getUserModulesPath());
	librarySearchPaths.push_back(VuoFileUtilities::getUserModulesPath());

	moduleSearchPaths.push_back(getCachedModulesPath());
}

/**
 * Adds a module file after @ref listModulesAtSearchPath() has already cached the list of module files
 * for the cache's Modules folder.
 */
void VuoCompiler::Environment::addCachedModuleFileToSharedEnvironment(const string &moduleRelativePath)
{
	dispatch_sync(environmentQueue, ^{
					  string cachedModulesPath = getCachedModulesPath();
					  VuoFileUtilities::File *moduleFile = new VuoFileUtilities::File(cachedModulesPath, moduleRelativePath);

					  string dir, moduleKey, ext;
					  VuoFileUtilities::splitPath(moduleRelativePath, dir, moduleKey, ext);

					  moduleFilesAtSearchPath[cachedModulesPath][moduleKey] = moduleFile;
				  });
}

/**
 * Removes a module file after @ref listModulesAtSearchPath() has already cached the list of module files
 * for the cache's Modules folder.
 */
void VuoCompiler::Environment::removeCachedModuleFileFromSharedEnvironment(const string &moduleKey)
{
	dispatch_sync(environmentQueue, ^{
					  string cachedModulesPath = getCachedModulesPath();
					  moduleFilesAtSearchPath[cachedModulesPath].erase(moduleKey);
				  });
}

/**
 * Adds a composition file after @ref listCompositionsAtSearchPath() has already cached the list of
 * composition files for the subcomposition's folder.
 */
void VuoCompiler::Environment::addSubcompositionFileToSharedEnvironment(const string &subcompositionPath)
{
	dispatch_sync(environmentQueue, ^{
					  string dir, moduleKey, ext;
					  VuoFileUtilities::splitPath(subcompositionPath, dir, moduleKey, ext);
					  VuoFileUtilities::canonicalizePath(dir);

					  VuoFileUtilities::File *subcompositionFile = new VuoFileUtilities::File(dir, moduleKey + "." + ext);

					  compositionFilesAtSearchPath[dir][moduleKey] = subcompositionFile;
				  });
}

/**
 * Removes a composition file after @ref listCompositionsAtSearchPath() has already cached the list of
 * composition files for the subcomposition's folder.
 */
void VuoCompiler::Environment::removeSubcompositionFileFromSharedEnvironment(const string &nodeClassName)
{
	dispatch_sync(environmentQueue, ^{
					  set<string> nodeClassNameSet;
					  nodeClassNameSet.insert(nodeClassName);
					  set<ModuleInfo> subcompositions = listSubcompositions(nodeClassNameSet);

					  for (set<ModuleInfo>::iterator i = subcompositions.begin(); i != subcompositions.end(); ++i) {
						  compositionFilesAtSearchPath[(*i).searchPath].erase((*i).moduleKey);
					  }
				  });
}

/**
 * Checks each module in the cached Modules folder for a corresponding composition (.vuo) file in
 * the user Modules folder, and if none exists, deletes the module.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::removeCachedModulesForDeletedSubcompositions(void)
{
	string moduleSearchPath = getCachedModulesPath();

	map<string, VuoFileUtilities::File *> subcompositionModules = listModulesAtSearchPath(moduleSearchPath);
	for (map<string, VuoFileUtilities::File *>::iterator i = subcompositionModules.begin(); i != subcompositionModules.end(); ++i)
	{
		string moduleKey = i->first;
		VuoFileUtilities::File *moduleFile = i->second;

		string subcompositionSourcePath = VuoFileUtilities::getUserModulesPath() + "/" + moduleKey + ".vuo";
		if (! VuoFileUtilities::fileExists(subcompositionSourcePath))
		{
			string subcompositionModulePath = moduleSearchPath + "/" + moduleFile->getRelativePath();
			VuoFileUtilities::deleteFile(subcompositionModulePath);

			moduleFilesAtSearchPath[moduleSearchPath].erase(moduleKey);
		}
	}
}

/**
 * Creates a compiler instance that can be used for compiling and linking.
 */
VuoCompiler::VuoCompiler(void)
	: myEnvironment(true), combinedEnvironment(false)
{
	dispatch_sync(llvmQueue, ^{
					  if (! isLlvmInitialized)
					  {
						  isLlvmInitialized = true;

						  llvm::InitializeNativeTarget();

						  // If the Vuo compiler/linker...
						  //   1. Loads a node class that uses dispatch_object_t.
						  //   2. Generates code that uses dispatch_object_t.
						  //   3. Links the node class into a composition.
						  //   4. Generates more code that uses dispatch_object_t.
						  // ... then Step 4 ends up with the wrong llvm::Type for dispatch_object_t.
						  //
						  // A workaround is to generate some code that uses dispatch_object_t before doing Step 1.
						  //
						  // https://b33p.net/kosada/node/3845
						  // http://lists.cs.uiuc.edu/pipermail/llvmdev/2012-December/057075.html
						  Module module("", getGlobalContext());
						  VuoCompilerCodeGenUtilities::getDispatchObjectType(&module);

						  // Workaround for a possibly related error where the compiler ends up with the wrong
						  // llvm::Type for dispatch_semaphore_s.  https://b33p.net/kosada/node/10545
						  VuoCompilerCodeGenUtilities::getDispatchSemaphoreType(&module);

						  // Load the NodeContext and PortContext struct types preemptively to make sure that
						  // their fields get the right dispatch types. If these struct types were to be loaded
						  // first from a subcomposition module, they'd get the wrong dispatch types.
						  // https://b33p.net/kosada/node/11160
						  VuoCompilerCodeGenUtilities::getNodeContextType(&module);
						  VuoCompilerCodeGenUtilities::getPortContextType(&module);
					  }
				  });

	dependenciesCacheQueue = dispatch_queue_create("org.vuo.compiler.dependencies", NULL);
	modulesToLoadQueue = dispatch_queue_create("org.vuo.compiler.modules", NULL);
	shouldLoadAllModules = true;
	hasLoadedAllModules = false;
	isVerbose = false;
	licenseUsername = "unknownVuoUser";

	Environment *env = getSharedEnvironment();
	dispatch_sync(environmentQueue, ^{
					  combinedEnvironment.updateCombinedEnvironment( &myEnvironment, env );
				  });

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
		clangPath = vuoFrameworkPath + "/Frameworks/llvm.framework/Versions/A/Helpers/clang";
	else
		clangPath = llvm::sys::Path(StringRef(LLVM_ROOT "/bin/clang"));
}

/**
 * Destructor.
 */
VuoCompiler::~VuoCompiler(void)
{
	dispatch_sync(cachedResourcesQueue, ^{});  // Wait for any asynchronous calls on this queue to complete.
}

/**
 * Returns the singleton shared by all VuoCompiler instances.
 */
VuoCompiler::Environment * VuoCompiler::getSharedEnvironment(void)
{
	dispatch_sync(environmentQueue, ^{
					  if (! sharedEnvironment)
					  {
						  sharedEnvironment = new Environment(true);
						  sharedEnvironment->addSearchPathsToSharedEnvironment();
					  }
				  });

	return sharedEnvironment;
}

/**
 * Loads node classes, types, and library modules, and compiles and loads subcompositions, if they have not
 * already been loaded.
 *
 * If this is the first call to this function in which @ref shouldLoadAllModules is true, this function loads
 * all modules and subcompositions found in the compiler's search paths. Otherwise, this function loads only the
 * modules listed in @a moduleKeys and their dependencies.
 *
 * This function needs to be called before compiling a composition, linking a composition, or getting a listing
 * of loaded modules. It does not need to be called before compiling a node class.
 *
 * If there are any errors compiling subcompositions or loading modules, they are added to @ref errorsLoadingModules.
 */
void VuoCompiler::loadModulesIfNeeded(const set<string> &moduleKeys)
{
	set<ModuleInfo> allSubcompositions = getSharedEnvironment()->listAllSubcompositions();
	map<string, ModuleInfo> moduleInfoForSubcomposition;
	for (set<ModuleInfo>::iterator i = allSubcompositions.begin(); i != allSubcompositions.end(); ++i)
		moduleInfoForSubcomposition[(*i).moduleKey] = *i;

	__block bool willLoadAllModules = false;
	__block map< string, set<string> > subcompositionsWithinSubcompositionCopy;
	dispatch_sync(modulesToLoadQueue, ^{
					  if (shouldLoadAllModules && ! hasLoadedAllModules)
					  {
						  willLoadAllModules = true;
						  hasLoadedAllModules = true;
					  }

					  updateSubcompositionsWithinSubcomposition(moduleInfoForSubcomposition);
					  subcompositionsWithinSubcompositionCopy = subcompositionsWithinSubcomposition;
				  });

	set<ModuleInfo> modulesToLoad;
	set<string> subcompositionsToCompileUnsorted;

	if (willLoadAllModules)
	{
		// Get a list of all module files in all search paths.

		modulesToLoad = Environment::listAllModulesInEnvironments(&myEnvironment, getSharedEnvironment());

		// Get a list of all subcompositions in all search paths.

		for (map< string, set<string> >::iterator i = subcompositionsWithinSubcompositionCopy.begin(); i != subcompositionsWithinSubcompositionCopy.end(); ++i)
			subcompositionsToCompileUnsorted.insert(i->first);
	}
	else
	{
		// Get a list of files for the requested modules.

		modulesToLoad = Environment::listModulesInEnvironments(&myEnvironment, getSharedEnvironment(), moduleKeys);

		// Build a list of subcompositions that need to be compiled — those directly requested and their dependencies.

		list<string> moduleKeysToVisit;
		for (set<string>::const_iterator i = moduleKeys.begin(); i != moduleKeys.end(); ++i)
			if (subcompositionsWithinSubcompositionCopy.find(*i) != subcompositionsWithinSubcompositionCopy.end())
				moduleKeysToVisit.push_back(*i);

		while (! moduleKeysToVisit.empty())
		{
			string moduleKey = moduleKeysToVisit.front();
			moduleKeysToVisit.pop_front();

			subcompositionsToCompileUnsorted.insert(moduleKey);

			map< string, set<string> >::iterator subcompositionsWithin = subcompositionsWithinSubcompositionCopy.find(moduleKey);
			moduleKeysToVisit.insert(moduleKeysToVisit.end(), subcompositionsWithin->second.begin(), subcompositionsWithin->second.end());
		}
	}

	// Load the non=subcomposition modules and their dependencies.

	list<ModuleInfo> modulesToLoadList(modulesToLoad.begin(), modulesToLoad.end());
	combinedEnvironment.loadModulesIntoCombinedEnvironment(&myEnvironment, getSharedEnvironment(), modulesToLoadList);

	// Put the subcompositions in the order they should be compiled — those with no dependencies first,
	// and the rest after all of their dependencies have been compiled.

	vector<string> subcompositionsToCompile;
	map< string, set<string> > subcompositionsToVisit = subcompositionsWithinSubcompositionCopy;
	while (! subcompositionsToVisit.empty())
	{
		vector<string> subcompositionsReady;
		for (map< string, set<string> >::iterator i = subcompositionsToVisit.begin(); i != subcompositionsToVisit.end(); ++i)
			if (i->second.empty())
				subcompositionsReady.push_back(i->first);

		for (vector<string>::iterator i = subcompositionsReady.begin(); i != subcompositionsReady.end(); ++i)
		{
			string subcomposition = *i;

			if (subcompositionsToCompileUnsorted.find(subcomposition) != subcompositionsToCompileUnsorted.end())
				subcompositionsToCompile.push_back(subcomposition);

			subcompositionsToVisit.erase(subcomposition);
			for (map< string, set<string> >::iterator j = subcompositionsToVisit.begin(); j != subcompositionsToVisit.end(); ++j)
				j->second.erase(subcomposition);
		}
	}

	for (vector<string>::iterator i = subcompositionsToCompile.begin(); i != subcompositionsToCompile.end(); ++i)
	{
		string moduleKey = *i;
		ModuleInfo sourceModuleInfo = moduleInfoForSubcomposition[moduleKey];

		string subcompositionPath = sourceModuleInfo.searchPath + "/" + sourceModuleInfo.file->getRelativePath();

		// Compile the subcomposition.

		bool compiled = compileSubcompositionIfNeeded(subcompositionPath);
		if (compiled)
		{
			// Load the subcomposition module.

			set<string> moduleKeySet;
			moduleKeySet.insert(moduleKey);
			set<ModuleInfo> compiledModuleInfo = getSharedEnvironment()->listModules(moduleKeySet);

			list<ModuleInfo> compiledModuleInfoList(compiledModuleInfo.begin(), compiledModuleInfo.end());
			combinedEnvironment.loadModulesIntoCombinedEnvironment(&myEnvironment, getSharedEnvironment(), compiledModuleInfoList);

			// Uninstall any subcompositions that depend on this subcomposition so they'll get recompiled.

			set<string> dirtySubcompositions;
			dirtySubcompositions.insert(moduleKey);

			set<string> newDirtySubcompositions = dirtySubcompositions;
			while (! newDirtySubcompositions.empty())
			{
				set<string> currDirtySubcomopositions = newDirtySubcompositions;
				newDirtySubcompositions.clear();

				for (map< string, set<string> >::const_iterator j = subcompositionsWithinSubcompositionCopy.begin(); j != subcompositionsWithinSubcompositionCopy.end(); ++j)
				{
					vector<string> dirtySubcompositionsWithin;
					std::set_intersection(j->second.begin(), j->second.end(),
										  currDirtySubcomopositions.begin(), currDirtySubcomopositions.end(),
										  std::back_inserter(dirtySubcompositionsWithin));

					if (! dirtySubcompositionsWithin.empty())
						newDirtySubcompositions.insert(j->first);
				}

				dirtySubcompositions.insert(newDirtySubcompositions.begin(), newDirtySubcompositions.end());
			}

			dirtySubcompositions.erase(moduleKey);

			for (set<string>::iterator j = dirtySubcompositions.begin(); j != dirtySubcompositions.end(); ++j)
				uninstallSubcompositionModule(*j);
		}
	}
}

/**
 * Helper function for @ref loadModulesIfNeeded(). Rebuilds the subcomposition dependency graph if it's out-of-date.
 */
void VuoCompiler::updateSubcompositionsWithinSubcomposition(const map<string, ModuleInfo> &moduleInfoForSubcomposition)
{
	if (! subcompositionsWithinSubcomposition.empty())
		return;

	// Build the subcomposition dependency graph for all subcompositions in all search paths.

	map<string, string> pathForSubcomposition;
	for (map<string, ModuleInfo>::const_iterator i = moduleInfoForSubcomposition.begin(); i != moduleInfoForSubcomposition.end(); ++i)
	{
		ModuleInfo moduleInfo = i->second;
		string subcompositionPath = moduleInfo.searchPath + "/" + moduleInfo.file->getRelativePath();
		pathForSubcomposition[moduleInfo.moduleKey] = subcompositionPath;

		try
		{
			set<string> nodeClassesWithin = VuoCompilerGraphvizParser::getNodeClassNamesFromCompositionFile(subcompositionPath, this);

			set<string> subcompositionsWithin;
			for (set<string>::iterator j = nodeClassesWithin.begin(); j != nodeClassesWithin.end(); ++j)
				if (moduleInfoForSubcomposition.find(*j) != moduleInfoForSubcomposition.end())
					subcompositionsWithin.insert(*j);

			subcompositionsWithinSubcomposition[moduleInfo.moduleKey] = subcompositionsWithin;
		}
		catch (VuoCompilerException &e)
		{
			dispatch_sync(errorsLoadingModulesQueue, ^{
							  errorsLoadingModules[moduleInfo.moduleKey] = make_pair(subcompositionPath, e);
						  });
		}
		catch (std::runtime_error &e)
		{
			VuoCompilerError error(e.what(), "", set<VuoNode *>(), set<VuoCable *>());
			VuoCompilerException exception(vector<VuoCompilerError>(1, error));
			dispatch_sync(errorsLoadingModulesQueue, ^{
							  errorsLoadingModules[moduleInfo.moduleKey] = make_pair(subcompositionPath, exception);
						  });
		}
	}

	// Check the subcomposition dependency graph for any subcomposition that contains itself, directly or indirectly.

	map< string, set<string> > subcompositionsToVisit = subcompositionsWithinSubcomposition;
	while (! subcompositionsToVisit.empty())
	{
		vector<string> subcompositionsReady;
		for (map< string, set<string> >::iterator i = subcompositionsToVisit.begin(); i != subcompositionsToVisit.end(); ++i)
			if (i->second.empty())
				subcompositionsReady.push_back(i->first);

		if (subcompositionsReady.empty())
			break;

		for (vector<string>::iterator i = subcompositionsReady.begin(); i != subcompositionsReady.end(); ++i)
		{
			string subcomposition = *i;

			subcompositionsToVisit.erase(subcomposition);
			for (map< string, set<string> >::iterator j = subcompositionsToVisit.begin(); j != subcompositionsToVisit.end(); ++j)
				j->second.erase(subcomposition);
		}
	}

	for (map< string, set<string> >::iterator i = subcompositionsToVisit.begin(); i != subcompositionsToVisit.end(); ++i)
	{
		string subcomposition = i->first;
		string subcompositionPath = pathForSubcomposition[subcomposition];

		subcompositionsWithinSubcomposition.erase(subcomposition);
		VuoCompilerError error("Subcomposition contains itself", subcomposition, set<VuoNode *>(), set<VuoCable *>());
		dispatch_sync(errorsLoadingModulesQueue, ^{
						  errorsLoadingModules[subcomposition] = make_pair(subcompositionPath, VuoCompilerException(vector<VuoCompilerError>(1, error)));
					  });
	}
}

/**
 * Initializes the premium node loader with the license information provided.
 *
 * This function should be called before attempting to load any premium moduless.
 */
void VuoCompiler::setLicense(string licenseContent, string licenseSignature)
{
#ifdef PREMIUM_NODE_LOADER_ENABLED
	VuoPremium::initializeWithLicense(licenseContent, licenseSignature, licenseUsername);
#endif
}

/**
 * Initializes the premium node loader with the license information stored in the user's org.vuo.Editor settings file.
 */
void VuoCompiler::loadStoredLicense(bool showLicenseWarning)
{
#ifdef PREMIUM_NODE_LOADER_ENABLED
	VuoPremium::loadStoredLicense(showLicenseWarning, licenseUsername);
#endif
}

/**
 * @deprecated
 */
void VuoCompiler::loadStoredLicense(void)
{
	VuoCompiler::loadStoredLicense(false);
}

/**
 * Returns the username from the active license.
 */
string VuoCompiler::getLicenseUsername()
{
	return licenseUsername;
}

/**
 * Updates the nodes and ports of the composition to have the correct backing types for generic types.
 */
void VuoCompiler::reifyGenericPortTypes(VuoCompilerComposition *composition)
{
	set<VuoNode *> nodes = composition->getBase()->getNodes();
	for (set<VuoNode *>::iterator i = nodes.begin(); i != nodes.end(); ++i)
		reifyGenericPortTypes(*i);
}

/**
 * Updates the ports of the node to have the correct backing types for generic types.
 */
void VuoCompiler::reifyGenericPortTypes(VuoNode *node)
{
	VuoCompilerSpecializedNodeClass *nodeClass = dynamic_cast<VuoCompilerSpecializedNodeClass *>(node->getNodeClass()->getCompiler());
	if (! nodeClass)
		return;

	// Reify any generic types on the node that don't already have a compiler detail.

	vector<VuoPort *> inputPorts = node->getInputPorts();
	vector<VuoPort *> outputPorts = node->getOutputPorts();
	vector<VuoPort *> ports;
	ports.insert(ports.end(), inputPorts.begin(), inputPorts.end());
	ports.insert(ports.end(), outputPorts.begin(), outputPorts.end());

	for (vector<VuoPort *>::iterator j = ports.begin(); j != ports.end(); ++j)
	{
		VuoCompilerPort *port = static_cast<VuoCompilerPort *>((*j)->getCompiler());
		VuoGenericType *genericType = dynamic_cast<VuoGenericType *>(port->getDataVuoType());
		if (! genericType)
			continue;

		if (! genericType->hasCompiler())
		{
			VuoCompilerGenericType *reifiedType = VuoCompilerGenericType::newGenericType(genericType, this);
			if (reifiedType)
				port->setDataVuoType(reifiedType->getBase());
		}
	}

	// Update the node class's backing to match the node's backing.

	nodeClass->updateBackingNodeClass(node, this);
}

/**
 * Compiles a node class, port type, or library module to LLVM bitcode.
 *
 * @param inputPath The file to compile, containing a C implementation of the node class, port type, or library module.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 */
void VuoCompiler::compileModule(string inputPath, string outputPath)
{
	compileModule(inputPath, outputPath, vector<string>());
}

/**
 * Compiles a node class, port type, or library module to LLVM bitcode.
 *
 * @param inputPath The file to compile, containing a C implementation of the node class, port type, or library module.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param includePaths Directories with header files to be included when compiling.
 */
void VuoCompiler::compileModule(string inputPath, string outputPath, const vector<string> &includePaths)
{
	if (isVerbose)
		print();

	vector<string> allIncludePaths = includePaths;
	string preprocessedInputPath = inputPath;

	string tmpPreprocessedInputDir;
	string dir, file, ext;
	VuoFileUtilities::splitPath(inputPath, dir, file, ext);
	if (ext == "c")
	{
		string inputContents = VuoFileUtilities::readFileToString(inputPath);
		string preprocessedInputContents = inputContents;
		VuoCompilerSpecializedNodeClass::replaceGenericTypesWithBacking(preprocessedInputContents);
		if (inputContents != preprocessedInputContents)
		{
			// Unspecialized generic node class
			allIncludePaths.push_back(dir.empty() ? "." : dir);
			tmpPreprocessedInputDir = VuoFileUtilities::makeTmpDir(file);
			preprocessedInputPath = tmpPreprocessedInputDir + "/" + file + "." + ext;
			VuoFileUtilities::preserveOriginalFileName(preprocessedInputContents, file + "." + ext);
			VuoFileUtilities::writeStringToFile(preprocessedInputContents, preprocessedInputPath);
		}
	}

	vector<string> extraArgs;
	for (vector<string>::iterator i = allIncludePaths.begin(); i != allIncludePaths.end(); ++i)
	{
		extraArgs.push_back("-I");
		extraArgs.push_back(*i);
	}

	string macosxSdkFolder = "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/";
	if (VuoFileUtilities::fileExists(macosxSdkFolder + "MacOSX10.9.sdk"))
	{
		extraArgs.push_back("-isysroot");
		extraArgs.push_back(macosxSdkFolder + "MacOSX10.9.sdk");
	}
	else if (VuoFileUtilities::fileExists(macosxSdkFolder + "MacOSX10.10.sdk"))
	{
		extraArgs.push_back("-isysroot");
		extraArgs.push_back(macosxSdkFolder + "MacOSX10.10.sdk");
	}

	Module *module = readModuleFromC(preprocessedInputPath, extraArgs);
	if (! tmpPreprocessedInputDir.empty())
		remove(tmpPreprocessedInputDir.c_str());
	if (! module)
	{
		vector<VuoCompilerError> errors;
		string details = "The node <code>" + file + "</code> couldn't be compiled to bitcode.  Check the macOS Console for details.";
		VuoCompilerError error("Broken node", details, set<VuoNode *>(), set<VuoCable *>());
		errors.push_back(error);
		throw VuoCompilerException(errors);
	}

	string moduleKey = getModuleNameForPath(inputPath);
	dispatch_sync(llvmQueue, ^{
					  VuoCompilerModule *compilerModule = VuoCompilerModule::newModule(moduleKey, module, "");
					  if (! compilerModule)
					  {
						  VUserLog("Error: Didn't recognize '%s' as a node class, type, or library.", inputPath.c_str());
						  return;
					  }

					  setTargetForModule(module, target);
					  writeModuleToBitcode(module, outputPath);

					  delete module;
				  });
}

/**
 * Compiles a composition to LLVM bitcode.
 *
 * If the composition contains generic nodes, then it may be modified to allow these generic nodes to be compiled.
 * See reifyGenericPortTypes() for more information.
 *
 * @param composition The composition to compile.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param isTopLevelComposition True if the composition is top-level, false if it's a subcomposition.
 * @throw VuoCompilerException The composition is invalid.
 */
void VuoCompiler::compileComposition(VuoCompilerComposition *composition, string outputPath, bool isTopLevelComposition)
{
	composition->check();

	reifyGenericPortTypes(composition);

	string moduleKey = getModuleNameForPath(outputPath);
	VuoCompilerBitcodeGenerator *generator = VuoCompilerBitcodeGenerator::newBitcodeGeneratorFromComposition(composition,
																											 isTopLevelComposition,
																											 moduleKey, this);
	if (telemetry == "console")
		generator->setDebugMode(true);

	dispatch_sync(llvmQueue, ^{
					  Module *module = generator->generateBitcode();
					  setTargetForModule(module, target);
					  writeModuleToBitcode(module, outputPath);
				  });

	delete generator;
}

/**
 * Compiles a composition, read from file, to LLVM bitcode.
 *
 * @param inputPath The .vuo file containing the composition.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param isTopLevelComposition True if the composition is top-level, false if it's a subcomposition.
 * @throw VuoCompilerException The composition is invalid.
 */
void VuoCompiler::compileComposition(string inputPath, string outputPath, bool isTopLevelComposition)
{
	VDebugLog("Compiling '%s'…", inputPath.c_str());
	if (isVerbose)
		print();

	if (!VuoFileUtilities::fileContainsReadableData(inputPath))
	{
		vector<VuoCompilerError> errors;
		string details = "The composition file at '" + inputPath + "' couldn't be read or was empty.";
		VuoCompilerError error("Couldn't parse the composition", details, set<VuoNode *>(), set<VuoCable *>());
		errors.push_back(error);
		throw VuoCompilerException(errors);
	}

	string compositionString = VuoFileUtilities::readFileToString(inputPath);
	compileCompositionString(compositionString, outputPath, isTopLevelComposition);
	VDebugLog("Done.");
}

/**
 * @deprecated
 */
void VuoCompiler::compileComposition(string inputPath, string outputPath)
{
	compileComposition(inputPath, outputPath, true);
}

/**
 * Compiles the composition, read from a string, to LLVM bitcode.
 *
 * @param compositionString A string containing the composition.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param isTopLevelComposition True if the composition is top-level, false if it's a subcomposition.
 * @throw VuoCompilerException The composition is invalid.
 */
void VuoCompiler::compileCompositionString(const string &compositionString, string outputPath, bool isTopLevelComposition)
{
	VuoCompilerComposition *composition = VuoCompilerComposition::newCompositionFromGraphvizDeclaration(compositionString, this);
	compileComposition(composition, outputPath, isTopLevelComposition);

	VuoComposition *baseComposition = composition->getBase();
	delete composition;
	delete baseComposition;
}

/**
 * Compiles the composition to a node class, unless the node class file already exists and is up-to-date.
 */
bool VuoCompiler::compileSubcompositionIfNeeded(const string &compositionPath)
{
	string cachedModulesPath = getCachedModulesPath();

	string dir, nodeClassName, ext;
	VuoFileUtilities::splitPath(compositionPath, dir, nodeClassName, ext);
	string compiledCompositionPath = cachedModulesPath + "/" + nodeClassName + ".vuonode";

	// Skip compiling if the subcomposition is known to be invalid.
	__block bool hasError;
	dispatch_sync(errorsLoadingModulesQueue, ^{
					  hasError = (errorsLoadingModules.find(nodeClassName) != errorsLoadingModules.end());
				  });
	if (hasError)
		return false;

	// Skip compiling if the subcomposition is up-to-date.
	if (VuoFileUtilities::fileExists(compiledCompositionPath) &&
			VuoFileUtilities::getFileLastModifiedInSeconds(compiledCompositionPath) >= VuoFileUtilities::getFileLastModifiedInSeconds(compositionPath))
		return false;

	// Compile the subcomposition.
	try
	{
		VuoFileUtilities::makeDir(cachedModulesPath);
		compileComposition(compositionPath, compiledCompositionPath, false);

		getSharedEnvironment()->addCachedModuleFileToSharedEnvironment(nodeClassName + ".vuonode");

		return true;
	}
	catch (VuoCompilerException &e)
	{
		dispatch_sync(errorsLoadingModulesQueue, ^{
						  errorsLoadingModules[nodeClassName] = make_pair(compositionPath, e);
					  });

		return false;
	}
}

/**
 * Compiles the .vuo file at @a compositionPath, loads it as a node class, and returns the node class.
 *
 * The compiled node class is placed in the cached Modules folder.
 *
 * @throw VuoCompilerException The composition could not be compiled.
 */
VuoCompilerNodeClass * VuoCompiler::installSubcomposition(string compositionPath)
{
	string dir, file, ext;
	VuoFileUtilities::splitPath(compositionPath, dir, file, ext);
	string nodeClassName = file;

	if (getSharedEnvironment()->getNodeClass(nodeClassName))
		uninstallSubcomposition(nodeClassName);

	getSharedEnvironment()->addSubcompositionFileToSharedEnvironment(compositionPath);

	dispatch_sync(modulesToLoadQueue, ^{
					  subcompositionsWithinSubcomposition.clear();
				  });

	VuoCompilerNodeClass *nodeClass = getNodeClass(nodeClassName);

	if (! nodeClass)
	{
		map<string, pair<string, VuoCompilerException> >::iterator iter = errorsLoadingModules.find(nodeClassName);
		if (iter != errorsLoadingModules.end())
		{
			VuoCompilerException e = iter->second.second;
			errorsLoadingModules.erase(iter);
			throw e;
		}
	}

	return nodeClass;
}

/**
 * Deletes a compiled subcomposition from the cached Modules folder and unloads the node class.
 */
void VuoCompiler::uninstallSubcomposition(string nodeClassName)
{
	getSharedEnvironment()->removeSubcompositionFileFromSharedEnvironment(nodeClassName);
	uninstallSubcompositionModule(nodeClassName);

	dispatch_sync(modulesToLoadQueue, ^{
					  subcompositionsWithinSubcomposition.clear();
				  });
}

/**
 * Deletes a compiled subcomposition from the cached Modules folder and unloads the node class.
 */
void VuoCompiler::uninstallSubcompositionModule(string nodeClassName)
{
	string compiledSubcompositionPath = getCachedModulesPath() + "/" + nodeClassName + ".vuonode";
	VuoFileUtilities::deleteFile(compiledSubcompositionPath);

	getSharedEnvironment()->removeCachedModuleFileFromSharedEnvironment(nodeClassName);
	combinedEnvironment.removeNodeClassFromCombinedEnvironment(nodeClassName, &myEnvironment, getSharedEnvironment());

	dispatch_sync(cachedResourcesQueue, ^{
					  hasTriedCachedResources[1] = false;
				  });

	dispatch_sync(dependenciesCacheQueue, ^{
					  compatibleDependenciesCache.erase(nodeClassName);
					  incompatibleDependenciesCache.erase(nodeClassName);
				  });

	dispatch_sync(errorsLoadingModulesQueue, ^{
					  errorsLoadingModules.erase(nodeClassName);
				  });
}

/**
 * Turns a compiled composition into an executable by
 * linking in all of its dependencies and adding a main function.
 *
 * @param inputPath Path to the compiled composition (an LLVM bitcode file).
 * @param outputPath Path where the resulting executable should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting executable.
 * @param isApp If true, the resulting executable can be added to an app bundle.
 *			If false, the resulting executable will be headless unless the composition contains a window.
 * @param rPath An optional @c -rpath argument to be passed to clang.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *			or the linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateExecutable(string inputPath, string outputPath, Optimization optimization,
													bool isApp, string rPath)
{
	linkCompositionToCreateExecutableOrDynamicLibrary(inputPath, outputPath, optimization, false, isApp, rPath);
}

/**
 * Turns a compiled composition into a dynamic library by
 * linking in all of its dependencies.
 *
 * If you plan to run multiple compositions, or multiple instances of the same composition, in the same process
 * (@ref VuoRunner::newCurrentProcessRunnerFromDynamicLibrary), @a optimization should be `Optimization_FastBuild`
 * or `Optimization_FastBuildExistingCache`. This prevents conflicts between Objective-C classes (from nodes)
 * being defined in multiple loaded dynamic libraries.
 *
 * @param inputPath Path to the compiled composition (an LLVM bitcode file).
 * @param outputPath Path where the resulting dynamic library should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting dynamic library.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *			or the linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateDynamicLibrary(string inputPath, string outputPath, Optimization optimization)
{
	linkCompositionToCreateExecutableOrDynamicLibrary(inputPath, outputPath, optimization, true);
}

#include "VuoTimeUtilities.hh"
/**
 * Creates an executable or dynamic library that contains the composition and its dependencies.
 *
 * If creating an executable, a main function is added.
 *
 * @param compiledCompositionPath Path to the compiled composition (n LLVM bitcode file).
 * @param linkedCompositionPath Path where the resulting executable or dynamic library should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting executable or dynamic library.
 * @param isDylib True if creating a dynamic library, false if creating an executable.
 * @param isApp If true, the resulting executable can be added to an app bundle.
 *			If false, the resulting executable will be headless unless the composition contains a window.
 * @param rPath An optional @c -rpath argument to be passed to clang.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *			or the linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateExecutableOrDynamicLibrary(string compiledCompositionPath, string linkedCompositionPath,
																	Optimization optimization, bool isDylib, bool isApp, string rPath)
{
	if (isVerbose)
		print();

	if (optimization == Optimization_FastBuildExistingCache)
		shouldLoadAllModules = false;

	set<string> dependencies = getDependenciesForComposition(compiledCompositionPath);
	dependencies.insert(getRuntimeDependency());
	if (! isDylib)
		dependencies.insert(getRuntimeMainDependency());
	if (isApp)
	{
		/// @todo This is obsolete now that VuoApp_init() needs to be explicitly called (instead of merely linked in and called via static initializer).
		string applicationDependency = getApplicationDependency();
		set<string> incompatibleDependencies;
		getDependenciesRecursively(applicationDependency, dependencies, incompatibleDependencies);
	}
	set<Module *> modules;
	set<string> libraries;
	set<string> frameworks;
	getLinkerInputs(dependencies, optimization, modules, libraries, frameworks);

	libraries.insert(compiledCompositionPath);

	link(linkedCompositionPath, modules, libraries, frameworks, isDylib, rPath);
}

/**
 * Creates one dynamic library for the composition by itself and, if needed, another dynamic library for the
 * node classes and other resources that are dependencies of the composition.
 *
 * @param compiledCompositionPath Path to the compiled composition (an LLVM bitcode file).
 * @param linkedCompositionPath Path where the resulting dynamic library for the composition should be placed.
 * @param newLinkedResourcePath Path where the resulting dynamic library for the composition's resources should be placed.
 *				The dynamic library is only created if this version of the composition requires resources that are not in
 *				@c alreadyLinkedResources. When this function returns, if the dynamic library was created, then this
 *				argument is the same as when it was passed in; otherwise, this argument is the empty string.
 * @param alreadyLinkedResourcePaths Paths where the resulting dynamic libraries for the composition's resources have
 *				been placed in previous calls to this function. When this function returns, if a dynamic library was
 *				created at @c newLinkedResourcePath, it will be the last element in this list.
 * @param alreadyLinkedResources Names of resources that have been linked into the composition in previous calls to this
 *				function. When this function returns, any new resources will have been added to this list.
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition,
 *				or the linker encountered errors and failed. The values of @a newLinkedResourcePath,
 *				@a alreadyLinkedResourcePaths, and @a alreadyLinkedResources are unchanged.
 */
void VuoCompiler::linkCompositionToCreateDynamicLibraries(string compiledCompositionPath, string linkedCompositionPath,
														  string &newLinkedResourcePath, vector<string> &alreadyLinkedResourcePaths,
														  set<string> &alreadyLinkedResources)
{
	if (isVerbose)
		print();

	// Wait to update the passed-by-reference arguments until the end of this function, in case an exception is thrown.
	string tmpNewLinkedResourcePath = newLinkedResourcePath;
	vector<string> tmpAlreadyLinkedResourcePaths = alreadyLinkedResourcePaths;
	set<string> tmpAlreadyLinkedResources = alreadyLinkedResources;

	// Get the dependencies used by the new resources and not the previous resources.
	set<string> newDependencies = getDependenciesForComposition(compiledCompositionPath);
	set<string> newDependenciesCopy = newDependencies;
	for (set<string>::iterator i = newDependenciesCopy.begin(); i != newDependenciesCopy.end(); ++i)
		if (tmpAlreadyLinkedResources.find(*i) != tmpAlreadyLinkedResources.end())
			newDependencies.erase(newDependencies.find(*i));

	// Get the dynamic libraries and frameworks used by the new and previous resources.
	set<string> dylibs;
	set<string> frameworks;
	{
		set<Module *> modules;
		set<string> libraries;

		tmpAlreadyLinkedResources.insert(newDependencies.begin(), newDependencies.end());

		getLinkerInputs(tmpAlreadyLinkedResources, Optimization_FastBuild, modules, libraries, frameworks);

		for (set<string>::iterator i = libraries.begin(); i != libraries.end(); ++i)
			if (VuoStringUtilities::endsWith(*i, ".dylib"))
				dylibs.insert(*i);
	}

	// Link the new resource dylib, if needed.
	if (! newDependencies.empty())
	{
		set<Module *> modules;
		set<string> libraries;

		libraries.insert(tmpAlreadyLinkedResourcePaths.begin(), tmpAlreadyLinkedResourcePaths.end());
		libraries.insert(dylibs.begin(), dylibs.end());
		getLinkerInputs(newDependencies, Optimization_FastBuild, modules, libraries, frameworks);

		link(tmpNewLinkedResourcePath, modules, libraries, frameworks, true);

		tmpAlreadyLinkedResourcePaths.push_back(tmpNewLinkedResourcePath);
	}
	else
	{
		tmpNewLinkedResourcePath = "";
	}

	// Get the Vuo runtime dependency.
	set<string> vuoRuntimePaths;
	{
		set<Module *> modules;
		set<string> libraries;
		set<string> frameworks;

		set<string> dependencies;
		dependencies.insert(getRuntimeDependency());
		getLinkerInputs(dependencies, Optimization_FastBuild, modules, libraries, frameworks);
		vuoRuntimePaths = libraries;
	}

	// Link the composition.
	{
		set<Module *> modules;
		set<string> libraries;

		libraries.insert(compiledCompositionPath);
		libraries.insert(vuoRuntimePaths.begin(), vuoRuntimePaths.end());
		libraries.insert(tmpAlreadyLinkedResourcePaths.begin(), tmpAlreadyLinkedResourcePaths.end());
		libraries.insert(dylibs.begin(), dylibs.end());
		link(linkedCompositionPath, modules, libraries, frameworks, true);
	}

	newLinkedResourcePath = tmpNewLinkedResourcePath;
	alreadyLinkedResourcePaths = tmpAlreadyLinkedResourcePaths;
	alreadyLinkedResources = tmpAlreadyLinkedResources;
}

/**
 * Returns the names of dependencies (node classes, types, libraries, and frameworks)
 * needed for linking the composition.
 *
 * This includes the composition's nodes, their dependencies, and the libraries needed
 * by every linked composition. It does not include the Vuo runtime or a main function.
 *
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition.
 */
set<string> VuoCompiler::getDependenciesForComposition(const string &compiledCompositionPath)
{
	VDebugLog("Gathering dependencies for '%s'…", compiledCompositionPath.c_str());
	set<string> dependencies;

	// Add the node classes in the top-level composition and their dependencies.
	__block set<string> directDependencies;
	string moduleKey = getModuleNameForPath(compiledCompositionPath);
	Module *module = readModuleFromBitcode(compiledCompositionPath);
	dispatch_sync(llvmQueue, ^{
					  VuoCompilerModule *compilerModule = VuoCompilerModule::newModule(moduleKey, module, "");
					  directDependencies = compilerModule->getDependencies();
					  delete compilerModule;
				  });

	loadModulesIfNeeded(directDependencies);

	for (set<string>::iterator i = directDependencies.begin(); i != directDependencies.end(); ++i)
	{
		string dependency = *i;

		set<string> dependenciesToAdd;
		set<string> incompatibleDependencies;
		getDependenciesRecursively(dependency, dependenciesToAdd, incompatibleDependencies);

		if (incompatibleDependencies.empty())
		{
			dependencies.insert(dependenciesToAdd.begin(), dependenciesToAdd.end());
		}
		else
		{
			VuoCompilerTargetSet compositionTargets;
			compositionTargets.restrictToCurrentOperatingSystemVersion();

			string dependencyTargetString;
			VuoCompilerModule *module = getModule(dependency);
			if (module)
			{
				VuoCompilerTargetSet dependencyTargets = module->getCompatibleTargets();
				for (set<string>::iterator i = incompatibleDependencies.begin(); i != incompatibleDependencies.end(); ++i)
				{
					VuoCompilerModule *subModule = getModule(*i);
					if (subModule)
					{
						VuoCompilerTargetSet subDependencyTargets = subModule->getCompatibleTargets();
						dependencyTargets.restrictToBeCompatibleWithAllOf(subDependencyTargets);
					}
				}
				dependencyTargetString = dependencyTargets.toString();
			}
			else
				dependencyTargetString = "(unknown operating systems)";

			string details = dependency + " is only compatible with " + dependencyTargetString +
							 ", but this composition needs to run on " + compositionTargets.toString() + ".";
			vector<VuoCompilerError> errors;
			VuoCompilerError error("Node incompatible with operating system", details, set<VuoNode *>(), set<VuoCable *>());
			errors.push_back(error);
			throw VuoCompilerException(errors);
		}
	}

	// Add the libraries needed by every linked composition.
	vector<string> coreDependencies = getCoreVuoDependencies();
	dependencies.insert(coreDependencies.begin(), coreDependencies.end());

	VDebugLog("Done.");
	return dependencies;
}

/**
 * Adds @a dependency and the names of all of its dependencies to @a compatibleDependencies and @a incompatibleDependencies.
 *
 * @param dependency The current dependency being searched for its dependencies.
 * @param[out] compatibleDependencies The dependencies found so far by calls to this function that are compatible with
 *			the targets for building the composition.
 * @param[out] incompatibleDependencies The dependencies that are incompatible with the targets for building the
 *			composition.
 */
void VuoCompiler::getDependenciesRecursively(const string &dependency,
											 set<string> &compatibleDependencies, set<string> &incompatibleDependencies)
{
	map<string, int> dependencies = getDependenciesRecursivelyWithCache(dependency, vector<string>());

	for (map<string, int>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		if (i->second == 0)
			compatibleDependencies.insert(i->first);
		else
			incompatibleDependencies.insert(i->first);
	}
}

/**
 * Helper for the other getDependenciesRecursively() function.
 *
 * Returns a structure of dependencies visited, including @a dependency, where:
 *    - 0 = compatible
 *    - 1 = incompatible
 *    - 2 = compatibility not yet known
 *
 * Adds the dependencies visited to the cache (compatibleDependenciesCache and incompatibleDependenciesCache).
 */
map<string, int> VuoCompiler::getDependenciesRecursivelyWithCache(const string &dependency, const vector<string> &ancestorsVisited)
{
	__block map<string, int> dependenciesForSelf;

	// Check if already visited (circular dependency).
	vector<string>::const_iterator av = find(ancestorsVisited.begin(), ancestorsVisited.end(), dependency);
	if (av != ancestorsVisited.end())
	{
		dependenciesForSelf[dependency] = 2;
		return dependenciesForSelf;
	}

	// Check if already cached.
	__block bool isCached = false;
	dispatch_sync(dependenciesCacheQueue, ^{
					  map<string, set<string> >::iterator cdIter = compatibleDependenciesCache.find(dependency);
					  if (cdIter != compatibleDependenciesCache.end())
					  {
						  isCached = true;
						  for (set<string>::iterator i = cdIter->second.begin(); i != cdIter->second.end(); ++i)
							  dependenciesForSelf[*i] = 0;
					  }

					  map<string, set<string> >::iterator icdIter = incompatibleDependenciesCache.find(dependency);
					  if (icdIter != incompatibleDependenciesCache.end())
					  {
						  isCached = true;
						  for (set<string>::iterator i = icdIter->second.begin(); i != icdIter->second.end(); ++i)
							  dependenciesForSelf[*i] = 0;
					  }
				  });
	if (isCached)
		return dependenciesForSelf;

	// If the composition was compiled with a different VuoCompiler instance, then node classes
	// that were generated at compile time need to be re-generated for this VuoCompiler instance.
	VuoCompilerNodeClass *nodeClass = getNodeClass(dependency);

	// See if the dependency is a node class, type, or library module, and therefore may have its
	// own dependencies.
	VuoCompilerModule *module = nodeClass ? nodeClass : getModule(dependency);

	bool isCompatible = true;
	if (module)
	{
		// Determine if the dependency is compatible with the targets.
		VuoCompilerTargetSet compositionTargets;
		compositionTargets.restrictToCurrentOperatingSystemVersion();
		isCompatible = module->getCompatibleTargets().isCompatibleWithAllOf(compositionTargets);

		// Add the dependencies of the dependency.
		vector<string> ancestorsAndSelfVisited = ancestorsVisited;
		ancestorsAndSelfVisited.push_back(dependency);
		set<string> children = module->getDependencies();
		for (set<string>::iterator i = children.begin(); i != children.end(); ++i)
		{
			string child = *i;

			map<string, int> dependenciesForChild = getDependenciesRecursivelyWithCache(child, ancestorsAndSelfVisited);
			dependenciesForSelf.insert(dependenciesForChild.begin(), dependenciesForChild.end());

			for (map<string, int>::iterator j = dependenciesForChild.begin(); j != dependenciesForChild.end(); ++j)
				if (j->second == 1)
					isCompatible = false;
		}
	}

	dependenciesForSelf[dependency] = isCompatible ? 0 : 1;

	set<string> compatibleDependenciesForSelf;
	set<string> incompatibleDependenciesForSelf;
	for (map<string, int>::iterator i = dependenciesForSelf.begin(); i != dependenciesForSelf.end(); ++i)
	{
		if (i->second == 0 || i->second == 2)
			compatibleDependenciesForSelf.insert(i->first);
		else if (i->second == 1)
			incompatibleDependenciesForSelf.insert(i->first);
	}

	dispatch_sync(dependenciesCacheQueue, ^{
					  // Add this dependency to the cache.
					  compatibleDependenciesCache[dependency].insert( compatibleDependenciesForSelf.begin(), compatibleDependenciesForSelf.end() );
					  incompatibleDependenciesCache[dependency].insert( incompatibleDependenciesForSelf.begin(), incompatibleDependenciesForSelf.end() );

					  // Update other dependencies in the cache that skipped this dependency because it wasn't fully visited yet.
					  for (map<string, int>::const_iterator i = dependenciesForSelf.begin(); i != dependenciesForSelf.end(); ++i)
					  {
						  string child = i->first;

						  if (compatibleDependenciesCache[child].find(dependency) != compatibleDependenciesCache[child].end())
						  {
							  if (! isCompatible)
								  compatibleDependenciesCache[child].erase(dependency);

							  compatibleDependenciesCache[child].insert( compatibleDependenciesForSelf.begin(), compatibleDependenciesForSelf.end() );
							  incompatibleDependenciesCache[child].insert( incompatibleDependenciesForSelf.begin(), incompatibleDependenciesForSelf.end() );
						  }
					  }
				  });

	return dependenciesForSelf;
}

/**
 * From a list of names of dependencies, gets the modules, library paths, and frameworks
 * to be passed to the linker.
 */
void VuoCompiler::getLinkerInputs(const set<string> &dependencies, Optimization optimization,
								  set<Module *> &modules, set<string> &libraries, set<string> &frameworks)
{
	set<string> allCachedResources;
	set<string> allCachedResourceDylibs;
	bool shouldUseCachedResources = optimization == Optimization_FastBuild || optimization == Optimization_FastBuildExistingCache;
	if (shouldUseCachedResources)
	{
		getCachedResources(optimization == Optimization_FastBuildExistingCache);
		for (int i = 0; i < NUM_CACHES; ++i)
		{
			allCachedResources.insert(cachedResources[i].begin(), cachedResources[i].end());
			allCachedResourceDylibs.insert(cachedResourceDylib[i]);
		}
	}

	// Use separate linkers for custom versus system search paths to control the order in which paths are searched.
	// Linker::addPaths() adds paths to the end, but Linker::addSystemPaths() adds them to the beginning.
	__block Linker *linker;
	__block Linker *systemLinker;
	vector<string> librarySearchPaths = combinedEnvironment.getLibrarySearchPaths();
	dispatch_sync(llvmQueue, ^{
					  linker = new Linker("", "", getGlobalContext());
					  linker->addPaths(librarySearchPaths);
					  systemLinker = new Linker("", "", getGlobalContext());
					  systemLinker->addSystemPaths();
				  });

	for (set<string>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		string dependency = *i;

		if (shouldUseCachedResources && allCachedResources.find(dependency) != allCachedResources.end())
			libraries.insert(allCachedResourceDylibs.begin(), allCachedResourceDylibs.end());
		else
		{
			VuoCompilerModule *module = getModule(dependency);
			if (module)
			{
				string modulePath = module->getModulePath();
				if (! modulePath.empty() && dynamic_cast<VuoCompilerType *>(module))
					libraries.insert(modulePath);
				else
					modules.insert(module->getModule());
			}
			else
			{
				if (VuoStringUtilities::endsWith(dependency, ".framework"))
					frameworks.insert(dependency);
				else
				{
					__block sys::Path dependencyPath;
					dispatch_sync(llvmQueue, ^{
									  dependencyPath = linker->FindLib(dependency);
								  });
					if (dependencyPath.isEmpty())
						dispatch_sync(llvmQueue, ^{
										  dependencyPath = systemLinker->FindLib(dependency);
									  });
					if (! dependencyPath.isEmpty())
						libraries.insert(dependencyPath.str());
					else
						VUserLog("Warning: Could not locate dependency '%s'.", dependency.c_str());
				}
			}
		}
	}

	dispatch_sync(llvmQueue, ^{
					  delete linker;
					  delete systemLinker;
				  });
}

/**
 * Initializes cachedResourceDylibs and cachedResources (if they haven't been already), allowing
 * them to be used when linking compositions.
 *
 * This function creates (or references, if it already exists and is up to date) a dynamic library
 * that contains:
 *   - all node classes, types, and library modules in the shared environment, except those that
 *     are premium or incompatible with the current operating system
 *   - their dependencies
 *   - the core dependencies needed by every composition
 *
 * If the dynamic library can't be created, cachedResourceDylibs and cachedResources are unchanged upon return.
 *
 * @threadNoQueue{cachedResourcesQueue}
 */
void VuoCompiler::getCachedResources(bool shouldUseExistingCache)
{
	dispatch_sync(cachedResourcesQueue, ^{
					  getCachedResourcesThreadUnsafe(shouldUseExistingCache);
				  });
}

/**
 * Version of getCachedResources() that doesn't wrap its code in cachedResourcesQueue.
 *
 * @threadQueue{cachedResourcesQueue}
 */
void VuoCompiler::getCachedResourcesThreadUnsafe(bool shouldUseExistingCache)
{
	static dispatch_once_t checked = 0;
	static bool prelinkCache = true;
	dispatch_once(&checked, ^{
		Boolean valid;
		bool result = CFPreferencesGetAppBooleanValue(CFSTR("prelinkCache"), CFSTR("org.vuo.Editor"), &valid);
		if (valid)
			prelinkCache = result;
	});
	if (!prelinkCache)
	{
		VDebugLog("Ignoring the cache since the 'prelinkCache' preference is false.");
		return;
	}

	try
	{

	bool hasTriedAllCachedResources = true;
	for (int i = 0; i < NUM_CACHES; ++i)
		hasTriedAllCachedResources = hasTriedAllCachedResources && hasTriedCachedResources[i];
	if (hasTriedAllCachedResources)
		return;


	// Part 1: Construct the list of resources expected to be in the cache.

	Environment *env = NULL;

	set<string> expectedResources[NUM_CACHES];
	set<Module *> modules[NUM_CACHES];
	set<string> libraries[NUM_CACHES];
	set<string> frameworks[NUM_CACHES];

	if (! shouldUseExistingCache)
	{
		// Add the loaded modules, the core dependencies, and their dependencies to the list.
		VDebugLog("Building cache list…");

		env = getSharedEnvironment();
		loadModulesIfNeeded();

		map<string, VuoCompilerModule *> allModules;
		map<string, VuoCompilerNodeClass *> nodeClasses = env->getNodeClasses();
		map<string, VuoCompilerType *> types = env->getTypes();
		map<string, VuoCompilerModule *> libraryModules = env->getLibraryModules();
		allModules.insert(nodeClasses.begin(), nodeClasses.end());
		allModules.insert(types.begin(), types.end());
		allModules.insert(libraryModules.begin(), libraryModules.end());

		set<string> dependencies[NUM_CACHES];
		for (map<string, VuoCompilerModule *>::iterator j = allModules.begin(); j != allModules.end(); ++j)
		{
			string moduleKey = j->first;
			VuoCompilerModule *module = j->second;

			if (module->getPremium())
				continue;

			set<string> dependenciesToAdd;
			set<string> incompatibleDependencies;
			getDependenciesRecursively(moduleKey, dependenciesToAdd, incompatibleDependencies);

			if (incompatibleDependencies.empty())
			{
				int i = (module->isBuiltIn() ? 0 : 1);
				dependencies[i].insert(dependenciesToAdd.begin(), dependenciesToAdd.end());
				expectedResources[i].insert(moduleKey);
			}
		}

		for (int i = 1; i < NUM_CACHES; ++i)
		{
			for (int j = 0; j < i; ++j)
			{
				set<string> uniqueDependencies;
				set_difference(dependencies[i].begin(), dependencies[i].end(),
							   dependencies[j].begin(), dependencies[j].end(),
							   std::inserter(uniqueDependencies, uniqueDependencies.end()));
				dependencies[i] = uniqueDependencies;

				set<string> uniqueExpectedResources;
				set_difference(expectedResources[i].begin(), expectedResources[i].end(),
							   expectedResources[j].begin(), expectedResources[j].end(),
							   std::inserter(uniqueExpectedResources, uniqueExpectedResources.end()));
				expectedResources[i] = uniqueExpectedResources;
			}
		}

		vector<string> coreDependencies = getCoreVuoDependencies();
		dependencies[0].insert(coreDependencies.begin(), coreDependencies.end());

		for (int i = 0; i < NUM_CACHES; ++i)
		{
			for (set<string>::iterator j = dependencies[i].begin(); j != dependencies[i].end(); ++j)
			{
				string dependency = *j;
				set<string> dependencySet;
				dependencySet.insert(dependency);

				set<Module *> modulesToAdd;
				set<string> librariesToAdd;
				set<string> frameworksToAdd;
				getLinkerInputs(dependencySet, Optimization_SmallBinary, modulesToAdd, librariesToAdd, frameworksToAdd);

				modules[i].insert(modulesToAdd.begin(), modulesToAdd.end());
				libraries[i].insert(librariesToAdd.begin(), librariesToAdd.end());
				frameworks[i].insert(frameworksToAdd.begin(), frameworksToAdd.end());

				if (! modulesToAdd.empty())
					expectedResources[i].insert(dependency);
				else if (! librariesToAdd.empty())
				{
					sys::Path libraryPath(*librariesToAdd.begin());
					if (libraryPath.isArchive() || libraryPath.isBitcodeFile())
						expectedResources[i].insert(dependency);
				}
			}
		}
	}


	string cacheDir = VuoFileUtilities::getCachePath();
	string cacheFileNames[2] = { "libVuoResources.dylib", "libVuoResources-user.dylib" };
	string indexFileNames[2] = { "index.txt", "index-user.txt" };
	string cacheFilePaths[2];
	const char separator = '\n';

	for (int i = 0; i < NUM_CACHES; ++i)
	{
		if (hasTriedCachedResources[i])
		{
			cacheFilePaths[i] = cachedResourceDylib[i];
		}
		else
		{
			hasTriedCachedResources[i] = true;
			cachedResourceDylib[i].clear();
			cachedResources[i].clear();


			// Part 2: Check if the cache contains an up-to-date version of each of the expected resources.
			VDebugLog("Checking %s cache status…", cacheFileNames[i].c_str());

			cacheFilePaths[i] = cacheDir + "/" + cacheFileNames[i];
			string indexFilePath = cacheDir + "/" + indexFileNames[i];
			bool isCacheUpToDate = true;

			if (! shouldUseExistingCache)
			{
				// Check if the cached files exist. If not, create them (without affecting their last modified date).
				bool cacheDirExists = VuoFileUtilities::fileExists(cacheDir);
				if (! cacheDirExists)
					VuoFileUtilities::makeDir(cacheDir);

				bool cacheFileExists = cacheDirExists && VuoFileUtilities::fileExists(cacheFilePaths[i]);
				if (! cacheFileExists)
					VuoFileUtilities::createFile(cacheFilePaths[i]);
				bool indexFileExists = cacheDirExists && VuoFileUtilities::fileExists(indexFilePath);
				if (! indexFileExists)
					VuoFileUtilities::createFile(indexFilePath);
				if (! cacheFileExists || ! indexFileExists)
					isCacheUpToDate = false;
			}

			// Lock the cached files for reading. The lock remain active until the process exits.
			VuoFileUtilities::File cacheFile = VuoFileUtilities::File(cacheDir, cacheFileNames[i]);
			cacheFile.lockForReading();

			// Check if the cached dylib file is newer than all of the loaded modules and libraries.
			if (isCacheUpToDate && ! shouldUseExistingCache)
			{
				unsigned long cacheFileLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(cacheFilePaths[i]);

				set<string> searchPaths;
				if (i == 0)
				{
					vector<string> moduleSearchPaths = env->getBuiltInModuleSearchPaths();
					vector<string> librarySearchPaths = env->getBuiltInLibrarySearchPaths();
					searchPaths.insert(moduleSearchPaths.begin(), moduleSearchPaths.end());
					searchPaths.insert(librarySearchPaths.begin(), librarySearchPaths.end());
				}
				else
				{
					vector<string> moduleSearchPaths = env->getModuleSearchPaths();
					vector<string> librarySearchPaths = env->getLibrarySearchPaths();
					vector<string> excludedModuleSearchPaths = env->getBuiltInModuleSearchPaths();
					vector<string> excludedLibrarySearchPaths = env->getBuiltInLibrarySearchPaths();
					for (vector<string>::iterator j = moduleSearchPaths.begin(); j != moduleSearchPaths.end(); ++j)
						if (find(excludedModuleSearchPaths.begin(), excludedModuleSearchPaths.end(), *j) == excludedModuleSearchPaths.end())
							searchPaths.insert(*j);
					for (vector<string>::iterator j = librarySearchPaths.begin(); j != librarySearchPaths.end(); ++j)
						if (find(excludedLibrarySearchPaths.begin(), excludedLibrarySearchPaths.end(), *j) == excludedLibrarySearchPaths.end())
							searchPaths.insert(*j);
				}

				for (set<string>::iterator j = searchPaths.begin(); j != searchPaths.end() && isCacheUpToDate; ++j)
				{
					string searchPath = *j;

					/// @todo Search recursively - https://b33p.net/kosada/node/2468
					set<VuoFileUtilities::File *> files = VuoFileUtilities::findAllFilesInDirectory(searchPath);
					for (set<VuoFileUtilities::File *>::iterator j = files.begin(); j != files.end(); ++j)
					{
						string filePath = searchPath + "/" + (*j)->getRelativePath();
						unsigned long fileLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(filePath);
						if (fileLastModified > cacheFileLastModified)
						{
							isCacheUpToDate = false;
							break;
						}
					}

					for (set<VuoFileUtilities::File *>::iterator j = files.begin(); j != files.end(); ++j)
						delete *j;
				}
			}

			// Check if the cached index file matches the list of loaded modules and libraries.
			vector<string> indexedResources;
			if (isCacheUpToDate)
			{
				VuoFileUtilities::File indexFile(cacheDir, indexFileNames[i]);
				string index = indexFile.getContentsAsString();
				indexedResources = VuoStringUtilities::split(index, separator);
			}

			if (isCacheUpToDate && ! shouldUseExistingCache)
			{
				if (indexedResources.size() != expectedResources[i].size())
				{
					isCacheUpToDate = false;
				}
				else
				{
					for (vector<string>::iterator j = indexedResources.begin(); j != indexedResources.end(); ++j)
					{
						if (expectedResources[i].find(*j) == expectedResources[i].end())
						{
							isCacheUpToDate = false;
							break;
						}
					}
				}
			}

			// Check if the dylib looks remotely valid.
			if (isCacheUpToDate)
				if (!VuoFileUtilities::fileContainsReadableData(cacheFilePaths[i]))
					isCacheUpToDate = false;


			// Part 3: If the cache is not up to date, (re)create it.

			try
			{
				if (isCacheUpToDate)
				{
					VDebugLog("\tUp-to-date.");
					cachedResources[i].insert(indexedResources.begin(), indexedResources.end());
				}
				else
				{
					VDebugLog("\tRebuilding…");
					// Try to upgrade the file lock for writing.
					bool gotLock = cacheFile.lockForWriting(true);

					if (gotLock)
					{
						// Link the dependencies to create the cached resources dylib.
						for (int j = 0; j < i; ++j)
						{
							libraries[i].insert(cacheFilePaths[j]);
							for (set<string>::iterator k = libraries[j].begin(); k != libraries[j].end(); ++k)
								if (VuoStringUtilities::endsWith(*k, ".dylib"))
									libraries[i].insert(*k);
						}
						link(cacheFilePaths[i], modules[i], libraries[i], frameworks[i], true);

						// Write the list of dependencies to the cached index.
						vector<string> expectedResourcesVector(expectedResources[i].begin(), expectedResources[i].end());
						string index = VuoStringUtilities::join(expectedResourcesVector, separator);
						VuoFileUtilities::writeStringToFile(index, indexFilePath);

						// Downgrade the file lock back to reading.
						cacheFile.lockForReading();

						cachedResources[i].insert(expectedResources[i].begin(), expectedResources[i].end());
						isCacheUpToDate = true;
					}
					else
						throw std::runtime_error("The cache file is being used by another process.");
				}

				if (isCacheUpToDate)
					cachedResourceDylib[i] = cacheFilePaths[i];
			}
			catch (exception &e)
			{
				VUserLog("Warning: Could not create the cache for the \"faster build\" optimization: %s", e.what());
			}
		}
	}

	VDebugLog("Done.");

	}
	catch (const exception &e)
	{
		VUserLog("Warning: Could not initialize caches: %s", e.what());
	}
}

/**
 * Asynchronously prepares the cache that enables compositions to build faster.
 *
 * The first time a composition is built with the "faster build" optimization, it waits until the cache
 * is prepared. Preparing the cache may take several seconds. By calling this function, the cache can be
 * prepared in advance, so that there's no delay when building the first composition.
 */
void VuoCompiler::prepareForFastBuild(void)
{
	dispatch_async(cachedResourcesQueue, ^{
					   getCachedResourcesThreadUnsafe();
				   });
}

/**
 * Controls whether the VuoCompiler should load all node classes, types, and library modules from the
 * module search paths the first time a module is needed.
 */
void VuoCompiler::setLoadAllModules(bool shouldLoadAllModules)
{
	dispatch_sync(modulesToLoadQueue, ^{
					  this->shouldLoadAllModules = shouldLoadAllModules;
				  });
}

/**
 * Links the given modules, libraries, and frameworks to create an executable or dynamic library.
 *
 * @param outputPath The resulting executable or dynamic library.
 * @param modules The LLVM modules to link in.
 * @param libraries The libraries to link in. If building an executable, one of them should contain a main function.
 * @param frameworks The frameworks to link in.
 * @param isDylib If true, the output file will be a dynamic library. Otherwise, it will be an executable.
 * @param rPath The @c -rpath argument to be passed to clang. If empty, the folder containing the Vuo framework on the build system will be used.
 * @throw VuoCompilerException clang or ld failed to link the given dependencies.
 */
void VuoCompiler::link(string outputPath, const set<Module *> &modules, const set<string> &libraries, const set<string> &frameworks, bool isDylib, string rPath)
{
	VDebugLog("Linking '%s'…", outputPath.c_str());
	// http://stackoverflow.com/questions/11657529/how-to-generate-an-executable-from-an-llvmmodule


	// Write all the modules with renamed symbols to a composite module file (since the linker can't operate on in-memory modules).
	string compositeModulePath = VuoFileUtilities::makeTmpFile("composite", "bc");
	dispatch_sync(llvmQueue, ^{
					  Module *compositeModule = new Module("composite", getGlobalContext());
					  setTargetForModule(compositeModule);
					  for (set<Module *>::const_iterator i = modules.begin(); i != modules.end(); ++i)
					  {
						  string error;
						  if (Linker::LinkModules(compositeModule, *i, Linker::PreserveSource, &error))
						  VUserLog("Error: Failed to link compositeModule: %s", error.c_str());
					  }
					  writeModuleToBitcode(compositeModule, compositeModulePath);
					  delete compositeModule;
				  });


	// llvm-3.1/llvm/tools/clang/tools/driver/driver.cpp

	llvm::sys::Path clangPath = getClangPath();

	vector<const char *> args;
	args.push_back(clangPath.c_str());

	args.push_back(compositeModulePath.c_str());

	vector<string> coreDependencies = getCoreVuoDependencies();
	for (set<string>::const_iterator i = libraries.begin(); i != libraries.end(); ++i)
	{
		string library = *i;

		for (vector<string>::iterator j = coreDependencies.begin(); j != coreDependencies.end(); ++j)
		{
			string coreDependency = *j;
			if (VuoStringUtilities::endsWith(library, "lib" + coreDependency + ".a"))
				args.push_back("-force_load");  // Load all symbols of static core dependencies, not just those used in the objects.
		}

		args.push_back(library.c_str());
	}

	// Add framework search paths
	vector<string> frameworkArguments;

	vector<string> frameworkSearchPaths = combinedEnvironment.getFrameworkSearchPaths();
	for (vector<string>::const_iterator i = frameworkSearchPaths.begin(); i != frameworkSearchPaths.end(); ++i)
	{
		string a = "-F"+*i;
		// Keep these std::strings around until after args is done being used, since the std::string::c_str() is freed when the std::string is deleted.
		frameworkArguments.push_back(a);
		args.push_back(a.c_str());
	}

	for (set<string>::const_iterator i = frameworks.begin(); i != frameworks.end(); ++i)
	{
		args.push_back("-framework");

		string frameworkName = *i;
		frameworkName = frameworkName.substr(0, frameworkName.length() - string(".framework").length());
		args.push_back(strdup(frameworkName.c_str()));
	}

	// Check for C Runtime path within Vuo.framework
	llvm::sys::Path cRuntimePath;
	llvm::sys::Path crt1Path;
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	string vuoFrameworkContainingFolder = vuoFrameworkPath + "/..";
	if (! vuoFrameworkPath.empty())
	{
		cRuntimePath = vuoFrameworkPath + "/Modules/";
		crt1Path = cRuntimePath;
		crt1Path.appendComponent("crt1.o");
	}

	// If we have located a bundled version of crt1.o, link it in explicitly rather than relying on
	// clang's heuristic to locate a system version.
	if (!isDylib && crt1Path.canRead())
	{
		args.push_back("-nostartfiles");
		args.push_back(crt1Path.c_str());
	}

	// Linker option necessary for compatibility with our bundled version of ld64:
	args.push_back("-Xlinker");
	args.push_back("--no-demangle");

	// Avoid generating unknown load commands.
	// http://www.cocoabuilder.com/archive/xcode/308488-load-commands-in-10-7-dylib-block-install-name-tool-on-10-6.html
	args.push_back("-Xlinker");
	args.push_back("-no_function_starts");
	args.push_back("-Xlinker");
	args.push_back("-no_version_load_command");

	if (isVerbose)
		args.push_back("-v");

	if (isDylib)
		args.push_back("-dynamiclib");

	// Tell the built dylib/executable where to find Vuo.framework
	/// @todo Once we can build app bundles (https://b33p.net/kosada/node/3362), copy only the needed dynamic dependencies into the app bundle, and change the rpath accordingly
	args.push_back("-rpath");
	string rPathArg = (!rPath.empty()? rPath : vuoFrameworkContainingFolder);
	args.push_back(rPathArg.c_str());

	// Allow clang to print meaningful error messages.
	clang::DiagnosticOptions *diagOptions = new clang::DiagnosticOptions();
	clang::TextDiagnosticPrinter *diagClient = new clang::TextDiagnosticPrinter(llvm::errs(), diagOptions);
	diagClient->setPrefix(clangPath.str());
	IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
	clang::DiagnosticsEngine Diags(DiagID, diagOptions, diagClient);

	clang::driver::Driver TheDriver(args[0], "x86_64-apple-macosx10.8.0", outputPath, true, Diags);

	TheDriver.CCCIsCXX = true;  // clang++ instead of clang

	OwningPtr<clang::driver::Compilation> C(TheDriver.BuildCompilation(args));

	int Res = 0;
	const clang::driver::Command *FailingCommand = 0;
	if (C)
		Res = TheDriver.ExecuteCompilation(*C, FailingCommand);

	// Clean up composite module file.
	remove(compositeModulePath.c_str());

	if (Res != 0)
	{
		vector<string> thirdPartyNodeClasses;
		map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
		for (map<string, VuoCompilerNodeClass *>::const_iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
		{
			string nodeClassName = i->first;
			if (! VuoStringUtilities::beginsWith(nodeClassName, "vuo."))
				thirdPartyNodeClasses.push_back(nodeClassName);
		}

		string details = "One or more nodes in this composition can't be used by this version of Vuo. ";
		if (! thirdPartyNodeClasses.empty())
		{
			details += "Make sure you're using the latest version of all the extra Vuo nodes you've installed:\n";
			sort(thirdPartyNodeClasses.begin(), thirdPartyNodeClasses.end());
			for (vector<string>::iterator i = thirdPartyNodeClasses.begin(); i != thirdPartyNodeClasses.end(); ++i)
				details += " • " + *i + "\n";
		}
		details += "Check the Console application for messages with more information about the problem.";

		vector<VuoCompilerError> errors;
		VuoCompilerError error("Node outdated or broken", details, set<VuoNode *>(), set<VuoCable *>());
		errors.push_back(error);
		throw VuoCompilerException(errors);
	}
	VDebugLog("Done.");
}

/**
 * Returns the LLVM module read from the node class, type, or library implementation at @c inputPath (a .c file).
 */
Module * VuoCompiler::readModuleFromC(string inputPath)
{
	return readModuleFromC(inputPath, vector<string>());
}

/**
 * Returns the LLVM module read from the node class, type, or library implementation at @c inputPath (a .c file).
 */
Module * VuoCompiler::readModuleFromC(string inputPath, const vector<string> &extraArgs)
{
	// llvm-3.1/llvm/tools/clang/examples/clang-interpreter/main.cpp

	vector<const char *> args;
	args.push_back(inputPath.c_str());
	args.push_back("-DVUO_COMPILER");
	args.push_back("-fblocks");

	vector<string> headerSearchPaths = combinedEnvironment.getHeaderSearchPaths();
	for (vector<string>::iterator i = headerSearchPaths.begin(); i != headerSearchPaths.end(); ++i)
	{
		args.push_back("-I");
		args.push_back(i->c_str());
	}

	if (isVerbose)
		args.push_back("-v");

	for (vector<string>::const_iterator i = extraArgs.begin(); i != extraArgs.end(); ++i)
		args.push_back(i->c_str());

	clang::DiagnosticOptions * diagOptions = new clang::DiagnosticOptions();
	IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
	clang::DiagnosticsEngine Diags(DiagID, diagOptions);

	OwningPtr<clang::CompilerInvocation> CI(new clang::CompilerInvocation);
	clang::CompilerInvocation::CreateFromArgs(*CI, &args[0], &args[0] + args.size(), Diags);

	clang::CompilerInstance Clang;
	Clang.setInvocation(CI.take());

	Clang.createDiagnostics(args.size(), &args[0]);
	if (!Clang.hasDiagnostics())
		return NULL;

	// See CompilerInvocation::GetResourcesPath -- though we're not calling it because we don't have MainAddr.
	llvm::sys::Path clangPath = getClangPath();
	llvm::sys::Path builtinHeaderSearchPath = clangPath;
	builtinHeaderSearchPath.eraseComponent();  // Remove /clang from foo/bin/clang
	builtinHeaderSearchPath.eraseComponent();  // Remove /bin   from foo/bin
	builtinHeaderSearchPath.appendComponent("lib");
	builtinHeaderSearchPath.appendComponent("clang");
	builtinHeaderSearchPath.appendComponent(CLANG_VERSION_STRING);  // foo/lib/clang/<version>
	Clang.getHeaderSearchOpts().ResourceDir = builtinHeaderSearchPath.str();

//	OwningPtr<clang::CodeGenAction> Act(new clang::EmitLLVMOnlyAction());  // @@@ return value of takeModule() is destroyed at the end of this function
	clang::CodeGenAction *Act = new clang::EmitLLVMOnlyAction();
	if (!Clang.ExecuteAction(*Act))
		return NULL;

	return Act->takeModule();
}

/**
 * Returns the LLVM module read from @a inputPath (an LLVM bitcode file).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcode(string inputPath)
{
	string dir, file, ext;
	VuoFileUtilities::splitPath(inputPath, dir, file, ext);
	VuoFileUtilities::File inputFile(dir, file + "." + ext);
	return readModuleFromBitcode(&inputFile);
}

/**
 * Returns the LLVM module read from @a inputFile (an LLVM bitcode file).
 *
 * @threadNoQueue{llvmQueue}
 *
 * @throw std::runtime_error The file couldn't be read.
 */
Module * VuoCompiler::readModuleFromBitcode(VuoFileUtilities::File *inputFile)
{
	size_t inputDataBytes;
	char *inputData = inputFile->getContentsAsRawData(inputDataBytes);

	string error;
	Module *module = readModuleFromBitcodeData(inputData, inputDataBytes, error);
	if (! module)
		VUserLog("Error: Couldn't parse module '%s': %s.", inputFile->getRelativePath().c_str(), error.c_str());

	free(inputData);

	return module;
}

/**
 * Returns the LLVM module read from @a inputData (a data buffer of size @a inputDataBytes).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcodeData(char *inputData, size_t inputDataBytes, string &error)
{
	__block Module *module;
	dispatch_sync(llvmQueue, ^{
					  StringRef inputDataAsStringRef(inputData, inputDataBytes);
					  MemoryBuffer *mb = MemoryBuffer::getMemBuffer(inputDataAsStringRef, "", false);
					  module = ParseBitcodeFile(&(*mb), getGlobalContext(), &error);
					  delete mb;
				  });
	return module;
}

/**
 * Calls the destructor for @a module, using the LLVM global context thread-safely.
 *
 * @threadNoQueue{llvmQueue}
 */
void VuoCompiler::deleteModule(Module *module)
{
	dispatch_sync(llvmQueue, ^{
					  delete module;
				  });
}

/**
 * Returns the set of premium module names that the compiler has attempted to load,
 * whether or not the loads were successful.
 */
set<string> VuoCompiler::getEncounteredPremiumModules(void)
{
	return encounteredPremiumModules;
}

/**
 * Returns the exceptions that were encountered when loading modules (indexed by file path),
 * and clears the list of stored exceptions.
 */
map<string, VuoCompilerException> VuoCompiler::checkForErrorsLoadingModules(void)
{
	loadModulesIfNeeded();

	__block map<string, VuoCompilerException> errorsByPath;
	dispatch_sync(errorsLoadingModulesQueue, ^{
					  for (map<string, pair<string, VuoCompilerException> >::iterator i = errorsLoadingModules.begin(); i != errorsLoadingModules.end(); ++i)
						  errorsByPath[i->second.first] = i->second.second;

					  errorsLoadingModules.clear();
				  });

	return errorsByPath;
}

/**
 * Verifies the LLVM module and writes it to @a outputPath (an LLVM bitcode file).
 *
 * Returns true if there was a problem verifying or writing the module.
 *
 * @threadQueue{llvmQueue}
 */
bool VuoCompiler::writeModuleToBitcode(Module *module, string outputPath)
{
	if (verifyModule(*module, PrintMessageAction))
	{
		VUserLog("Error: Module verification failed.");
		return true;
	}

	string err;
	raw_fd_ostream out(outputPath.c_str(), err);
	if (! err.empty())
	{
		VUserLog("Error: Couldn't open file '%s' for writing: %s", outputPath.c_str(), err.c_str());
		return true;
	}
	WriteBitcodeToFile(module, out);

	return false;
}

/**
 * Sets the target triple for @c module. If @c target is empty, uses the target triple of the host machine.
 *
 * @threadQueue{llvmQueue}
 */
void VuoCompiler::setTargetForModule(Module *module, string target)
{
/*
	string effectiveTarget = target;
	if (effectiveTarget.empty())
	{
		// llvm::sys::getDefaultTargetTriple() finds a target based on the host, but the "default" target is not necessarily the
		// same target that results from invoking command-line clang without a -target argument. That is the "effective" target.
		// For example, the "default" target could be x86_64-apple-darwin10.8.0 and the "effective" target could be x86_64-apple-macosx10.8.0.

		llvm::sys::Path clangPath = getClangPath();

		vector<const char *> args;
		args.push_back(clangPath.c_str());
		args.push_back("/bin/sh");  // Driver needs an input file (that exists) or it refuses to give you the correct effective target.

		clang::DiagnosticOptions * diagOptions = new clang::DiagnosticOptions();
		IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
		clang::DiagnosticsEngine Diags(DiagID, diagOptions);

		clang::driver::Driver TheDriver(args[0], llvm::sys::getDefaultTargetTriple(), "a.out", true, Diags);
		OwningPtr<clang::driver::Compilation> C(TheDriver.BuildCompilation(args));
		effectiveTarget = C->getDefaultToolChain().ComputeEffectiveClangTriple(C->getArgs());
	}

	module->setTargetTriple(effectiveTarget);
*/
	module->setTargetTriple("x86_64-apple-macosx10.8.0");
}

/**
 * Instantiates a node for the given node class.
 *
 * If the node class is a generic template (e.g. vuo.data.hold), then the node is instantiated with the specialized
 * version of the node class (e.g. vuo.data.hold.VuoGenericType1).
 *
 * @param nodeClass The node class from which to create the node.
 * @param title The node's title.
 * @param x The node's x-coordinate within the composition.
 * @param y The node's y-coordinate within the composition.
 */
VuoNode * VuoCompiler::createNode(VuoCompilerNodeClass *nodeClass, string title, double x, double y)
{
	VuoCompilerNodeClass *nodeClassForNode = VuoCompilerSpecializedNodeClass::getNodeClassForNode(nodeClass, this);
	return nodeClassForNode->newNode(title, x, y);
}

/**
 * Instantiates a node used during code generation to represent published input ports.
 */
VuoNode * VuoCompiler::createPublishedInputNode(vector<VuoPublishedPort *> publishedInputPorts)
{
	__block VuoNodeClass *publishedInputNodeClass;
	dispatch_sync(llvmQueue, ^{
					  publishedInputNodeClass = VuoCompilerPublishedInputNodeClass::newNodeClass(publishedInputPorts);
				  });
	if (static_cast<VuoCompilerSpecializedNodeClass *>(publishedInputNodeClass->getCompiler())->isFullySpecialized())
		combinedEnvironment.addNodeClassToCombinedEnvironment( publishedInputNodeClass->getCompiler(), &myEnvironment, getSharedEnvironment() );

	VuoNode *publishedInputNode = publishedInputNodeClass->getCompiler()->newNode();
	reifyGenericPortTypes(publishedInputNode);
	return publishedInputNode;
}

/**
 * Instantiates a node used during code generation to represent published output ports.
 */
VuoNode * VuoCompiler::createPublishedOutputNode(vector<VuoPublishedPort *> publishedOutputPorts)
{
	__block VuoNodeClass *publishedOutputNodeClass;
	dispatch_sync(llvmQueue, ^{
					  publishedOutputNodeClass = VuoCompilerPublishedOutputNodeClass::newNodeClass(publishedOutputPorts);
				  });
	if (static_cast<VuoCompilerSpecializedNodeClass *>(publishedOutputNodeClass->getCompiler())->isFullySpecialized())
		combinedEnvironment.addNodeClassToCombinedEnvironment( publishedOutputNodeClass->getCompiler(), &myEnvironment, getSharedEnvironment() );

	VuoNode *publishedOutputNode = publishedOutputNodeClass->getCompiler()->newNode();;
	reifyGenericPortTypes(publishedOutputNode);
	return publishedOutputNode;
}

/**
 * Returns the node class specified by @a nodeClassName, or null if it can't be found or loaded.
 *
 * The node class module is loaded or generated if it hasn't been already.
 *
 * @eg{
 *		VuoCompiler *compiler = new VuoCompiler();
 *		VuoCompilerNodeClass *nc = compiler->getNodeClass("vuo.math.add.VuoInteger");
 *		[...]
 *		delete compiler;
 * }
 */
VuoCompilerNodeClass * VuoCompiler::getNodeClass(const string &nodeClassName)
{
	if (VuoStringUtilities::endsWith(nodeClassName, ".framework"))
		return NULL;

	set<string> nodeClassNameSet;
	nodeClassNameSet.insert(nodeClassName);
	loadModulesIfNeeded(nodeClassNameSet);

	VuoCompilerNodeClass *nodeClass = combinedEnvironment.getNodeClass(nodeClassName);
	if (nodeClass)
		return nodeClass;

	set<ModuleInfo> knownModuleInfos = combinedEnvironment.listAllModules();
	set<string> knownModuleKeys;
	for (set<ModuleInfo>::iterator i = knownModuleInfos.begin(); i != knownModuleInfos.end(); ++i)
		knownModuleKeys.insert((*i).moduleKey);

	VuoNodeClass *baseNodeClass = VuoCompilerSpecializedNodeClass::newNodeClass(nodeClassName, this, llvmQueue, knownModuleKeys);
	if (baseNodeClass)
	{
		if (static_cast<VuoCompilerSpecializedNodeClass *>(baseNodeClass->getCompiler())->isFullySpecialized())
			combinedEnvironment.addNodeClassToCombinedEnvironment( baseNodeClass->getCompiler(), &myEnvironment, getSharedEnvironment() );

		set<string> dependencies = baseNodeClass->getCompiler()->getDependencies();
		loadModulesIfNeeded(dependencies);

		return baseNodeClass->getCompiler();
	}

	return NULL;
}

/**
 * Returns all node classes found and loaded, indexed by node class name.
 *
 * The node class modules are loaded if they haven't been already.
 */
map<string, VuoCompilerNodeClass *> VuoCompiler::getNodeClasses()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getNodeClasses();
}

/**
 * Returns the type specified by @a typeName, or null if it can't be found or loaded.
 *
 * The type module is loaded or generated if it haven't been already.
 */
VuoCompilerType * VuoCompiler::getType(const string &typeName)
{
	set<string> typeNameSet;
	typeNameSet.insert(typeName);
	loadModulesIfNeeded(typeNameSet);

	VuoCompilerType *type = combinedEnvironment.getType(typeName);

	if (! type && VuoGenericType::isGenericTypeName(typeName))
	{
		VuoGenericType *genericType = new VuoGenericType(typeName, vector<string>());
		type = VuoCompilerGenericType::newGenericType(genericType, this);
	}

	return type;
}

/**
 * Returns all types found and loaded, indexed by type name.
 *
 * The type modules are loaded if they haven't been already.
 */
map<string, VuoCompilerType *> VuoCompiler::getTypes()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getTypes();
}

/**
 * Returns all libraries found and loaded, indexed by key.
 *
 * The libraries are loaded if they haven't been already.
 */
map<string, VuoCompilerModule *> VuoCompiler::getLibraryModules()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getLibraryModules();
}

/**
 * Returns all node sets found and loaded, indexed by type name.
 *
 * The node class modules are loaded if they haven't been already.
 */
map<string, VuoNodeSet *> VuoCompiler::getNodeSets()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getNodeSets();
}

/**
 * Returns the node set with the given @a name, or null if it can't be found.
 *
 * The node class modules are loaded if they haven't been already.
 */
VuoNodeSet * VuoCompiler::getNodeSetForName(const string &name)
{
	loadModulesIfNeeded();

	return combinedEnvironment.findNodeSet(name);
}

/**
 * Looks up the VuoCompilerNodeClass, VuoCompilerType, or VuoCompilerModule specified by @a moduleKey.
 */
VuoCompilerModule * VuoCompiler::getModule(const string &moduleKey)
{
	return combinedEnvironment.findModule(moduleKey);
}

/**
 * Prints a list of all loaded node classes to standard output.
 *
 * The node class modules are loaded if they haven't been already.
 *
 * @param format The format for printing the node classes.
 *	- If "", prints each class name (e.g. vuo.math.count.VuoInteger), one per line.
 *	- If "dot", prints the declaration of a node as it would appear in a .vuo (DOT format) file,
 *		with a constant value set for each data+event input port
 *		and a comment listing metadata and port types for the node class.
 */
void VuoCompiler::listNodeClasses(const string &format)
{
	loadModulesIfNeeded();

	map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
	for (map<string, VuoCompilerNodeClass *>::const_iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
	{
		VuoCompilerNodeClass *nodeClass = i->second;
		if (format == "")
		{
			printf("%s\n", nodeClass->getBase()->getClassName().c_str());
		}
		else if (format == "path")
		{
			// TODO: If "path", prints the absolute path of each node class, one per line.
		}
		else if (format == "dot")
		{
			VuoCompilerNode *node = nodeClass->newNode()->getCompiler();

			printf("%s\n", nodeClass->getDoxygenDocumentation().c_str());
			printf("%s\n\n", node->getGraphvizDeclaration().c_str());

			delete node;
		}
	}
}

/**
 * Returns the file names of bitcode dependencies needed by every linked Vuo composition.
 *
 * These dependencies are added to the cache (`libVuoResources.dylib`)
 * and are thus only loaded once per process.
 */
vector<string> VuoCompiler::getCoreVuoDependencies(void)
{
	vector<string> dependencies;
	dependencies.push_back("VuoCompositionDiff.bc");
	dependencies.push_back("VuoCompositionState.bc");
	dependencies.push_back("VuoEventLoop.bc");
	dependencies.push_back("VuoHeap");
	dependencies.push_back("VuoLog.bc");
	dependencies.push_back("VuoNodeRegistry.bc");
	dependencies.push_back("VuoRuntimeCommunicator.bc");
	dependencies.push_back("VuoRuntimeContext.bc");
	dependencies.push_back("VuoRuntimePersistentState.bc");
	dependencies.push_back("VuoRuntimeState.bc");
	dependencies.push_back("VuoRuntimeUtilities.bc");
	dependencies.push_back("VuoTelemetry.bc");
	dependencies.push_back("VuoThreadManager.bc");
	dependencies.push_back("module.bc");
	dependencies.push_back("zmq");
	dependencies.push_back("json-c");
	dependencies.push_back("objc");
	dependencies.push_back("c");
	dependencies.push_back("AppKit.framework");
#ifdef COVERAGE
	dependencies.push_back(LLVM_ROOT "/lib/libprofile_rt.dylib");
#endif
	return dependencies;
}

/**
 * Returns the file name of the main function can accompany the Vuo runtime.
 */
string VuoCompiler::getRuntimeMainDependency(void)
{
	return "VuoRuntimeMain.bc";
}

/**
 * Returns the file name of the Vuo runtime.
 *
 * This dependency is NOT added to the cache (`libVuoResources.dylib`)
 * and is thus loaded individually for each composition within a process,
 * giving each composition its own set of global/static variables defined in this dependency.
 */
string VuoCompiler::getRuntimeDependency(void)
{
	return "VuoRuntime.bc";
}

/**
 * Returns the name of the library module that launches an application in the composition process.
 */
string VuoCompiler::getApplicationDependency(void)
{
	return "VuoWindow";
}

/**
 * Returns the path to the Clang binary.
 */
llvm::sys::Path VuoCompiler::getClangPath(void)
{
	return clangPath;
}

/**
 * Returns the name of the node class that would be located at @c path.
 */
string VuoCompiler::getModuleNameForPath(string path)
{
	string dir, file, extension;
	VuoFileUtilities::splitPath(path, dir, file, extension);
	return file;
}

/**
 * Adds a module search path (for node classes, types, and libraries) to use when linking a composition.
 */
void VuoCompiler::addModuleSearchPath(string path)
{
	myEnvironment.addModuleSearchPath(path);
	addLibrarySearchPath(path);
}

/**
 * Adds a header search path to use when compiling a node class.
 */
void VuoCompiler::addHeaderSearchPath(const string &path)
{
	myEnvironment.addHeaderSearchPath(path);
	combinedEnvironment.addHeaderSearchPath(path);
}

/**
 * Adds a library search path to use when linking a composition.
 */
void VuoCompiler::addLibrarySearchPath(const string &path)
{
	myEnvironment.addLibrarySearchPath(path);
	combinedEnvironment.addLibrarySearchPath(path);
}

/**
 * Adds a macOS framework search path to use when linking a composition.
 */
void VuoCompiler::addFrameworkSearchPath(const string &path)
{
	myEnvironment.addFrameworkSearchPath(path);
	combinedEnvironment.addFrameworkSearchPath(path);
}

/**
 * Sets the telemetry option to use when compiling a composition. Valid values are "on" and "console".
 */
void VuoCompiler::setTelemetry(const string &telemetry)
{
	this->telemetry = telemetry;
}

/**
 * Sets the target triple to use when compiling or linking.
 */
void VuoCompiler::setTarget(const string &target)
{
	this->target = target;
}

/**
 * Sets the verbosity to use when compiling or linking. If true, prints some debug info and passes the `-v` option to Clang.
 */
void VuoCompiler::setVerbose(bool isVerbose)
{
	this->isVerbose = isVerbose;
}

/**
 * Sets the path to the clang binary.
 */
void VuoCompiler::setClangPath(const string &clangPath)
{
	this->clangPath = llvm::sys::Path(StringRef(clangPath));
}

/**
 * Returns the path to the VuoCompositionLoader executable.
 */
string VuoCompiler::getCompositionLoaderPath(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	return (vuoFrameworkPath.empty() ?
				VUO_ROOT "/runtime/VuoCompositionLoader" :
				vuoFrameworkPath + "/Helpers/VuoCompositionLoader.app/Contents/MacOS/VuoCompositionLoader");
}

/**
 * Returns the path to the VuoCompositionStub dynamic library.
 */
string VuoCompiler::getCompositionStubPath(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	return (vuoFrameworkPath.empty() ?
				VUO_ROOT "/base/VuoCompositionStub.dylib" :
				vuoFrameworkPath + "/Modules/VuoCompositionStub.dylib");
}

/**
 * Returns the path to the Modules folder inside the compiler's cache.
 */
string VuoCompiler::getCachedModulesPath(void)
{
	return VuoFileUtilities::getCachePath() + "/Modules";
}

/**
 * Prints info about this compiler, for debugging.
 */
void VuoCompiler::print(void)
{
	fprintf(stderr, "Module (node class, type, library) search paths:\n");
	vector<string> moduleSearchPaths = combinedEnvironment.getModuleSearchPaths();
	for (vector<string>::iterator i = moduleSearchPaths.begin(); i != moduleSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Header search paths:\n");
	vector<string> headerSearchPaths = combinedEnvironment.getHeaderSearchPaths();
	for (vector<string>::iterator i = headerSearchPaths.begin(); i != headerSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Other library search paths:\n");
	vector<string> librarySearchPaths = combinedEnvironment.getLibrarySearchPaths();
	for (vector<string>::iterator i = librarySearchPaths.begin(); i != librarySearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Other framework search paths:\n");
	vector<string> frameworkSearchPaths = combinedEnvironment.getFrameworkSearchPaths();
	for (vector<string>::iterator i = frameworkSearchPaths.begin(); i != frameworkSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Framework path:\n");
	if (! VuoFileUtilities::getVuoFrameworkPath().empty())
		fprintf(stderr, " %s\n", VuoFileUtilities::getVuoFrameworkPath().c_str());
	fprintf(stderr, "Clang path:\n");
	if (! getClangPath().str().empty())
		fprintf(stderr, " %s\n", getClangPath().c_str());
}

/**
 * Creates a runner object that can run the composition in file @a compositionFilePath in a new process.
 *
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newSeparateProcessRunnerFromCompositionFile(string compositionFilePath)
{
	VuoCompiler compiler;
	string directory, file, extension;
	VuoFileUtilities::splitPath(compositionFilePath, directory, file, extension);
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile(file, "bc");
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile(file + "-linked", "");
	compiler.compileComposition(compositionFilePath, compiledCompositionPath, true);
	compiler.linkCompositionToCreateExecutable(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newSeparateProcessRunnerFromExecutable(linkedCompositionPath, directory, false, true);
}

/**
 * Creates a runner object that can run the composition in string @a composition in a new process.
 *
 * @param composition A serialized composition.
 * @param workingDirectory The directory used by nodes in the composition to resolve relative paths.
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newSeparateProcessRunnerFromCompositionString(string composition, string workingDirectory)
{
	VuoCompiler compiler;
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "bc");
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition-linked", "");
	compiler.compileCompositionString(composition, compiledCompositionPath, true);
	compiler.linkCompositionToCreateExecutable(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newSeparateProcessRunnerFromExecutable(linkedCompositionPath, workingDirectory, false, true);
}

/**
 * Creates a runner object that can run the composition in file @a compositionFilePath in this process.
 *
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newCurrentProcessRunnerFromCompositionFile(string compositionFilePath)
{
	VuoCompiler compiler;
	string directory, file, extension;
	VuoFileUtilities::splitPath(compositionFilePath, directory, file, extension);
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile(file, "bc");
	compiler.compileComposition(compositionFilePath, compiledCompositionPath, true);
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile(file, "dylib");
	compiler.linkCompositionToCreateDynamicLibrary(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newCurrentProcessRunnerFromDynamicLibrary(linkedCompositionPath, directory, true);
}

/**
 * Creates a runner object that can run the composition in string @a composition in this process.
 *
 * @param composition A serialized composition.
 * @param workingDirectory The directory used by nodes in the composition to resolve relative paths.
 * @throw VuoCompilerException The composition is invalid.
 */
VuoRunner * VuoCompiler::newCurrentProcessRunnerFromCompositionString(string composition, string workingDirectory)
{
	VuoCompiler compiler;
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "bc");
	compiler.compileCompositionString(composition, compiledCompositionPath, true);
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "dylib");
	compiler.linkCompositionToCreateDynamicLibrary(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newCurrentProcessRunnerFromDynamicLibrary(linkedCompositionPath, workingDirectory, true);
}
